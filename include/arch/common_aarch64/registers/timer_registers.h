//=====Automatically generated by python 3.6.4
//== working directory: /cygdrive/d/Pool/eclipse-workspace_aarch64/newspace/raspiOS/subprojects/python3_gen_engine/src
//== ../../../subprojects/python3_gen_engine/src/GenEngine.py  ../../../subprojects/python3_gen_engine/src/reg_defs/timer_registers.py  ../../../include/arch/common_aarch64/registers/timer_registers.h
#ifndef __INCLUDE_ARCH_COMMON_AARCH64_REGISTERS_TIMER_REGISTERS_H__
#define __INCLUDE_ARCH_COMMON_AARCH64_REGISTERS_TIMER_REGISTERS_H__
#include <def.h>


class RegCNTFRQ_EL0 {
public:

            uint32_t  ClockFrq:32;


    AS_MACRO RegCNTFRQ_EL0(uint32_t v)            {set(v);}
    AS_MACRO RegCNTFRQ_EL0& operator=(uint32_t v) {set(v);return *this;}
    AS_MACRO void set(uint32_t v) { *reinterpret_cast<uint32_t*>(this)=v;}
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<uint32_t*>(this);
    }


    AS_MACRO void dump()const
    {
        kout << "RegCNTFRQ_EL0: ";
            kout
                << "ClockFrq = " << ClockFrq << ", "
                << "\n";
    }



    AS_MACRO static RegCNTFRQ_EL0 read()
    { 
        RegCNTFRQ_EL0 res;
        __asm__ __volatile__("mrs %0,CNTFRQ_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTFRQ_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTFRQ_EL0\n\t":"=r"(*this));
        return *this;
    }

    AS_MACRO RegCNTFRQ_EL0 & setMandatoryFields()
    {
        ClockFrq = 0;
        return *this;
    }
    
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTFRQ_EL0,%0\n\t"::"r"(*this));
    }

}__attribute__((packed));



class RegCNTHCTL_EL2 {
public:

            uint32_t  EL1PCTEN:1;
            uint32_t  EL1PCEN:1;
            uint32_t  EVNTEN:1;
            uint32_t  EVNTDIR:1;
            uint32_t  EVNTI:4;
            uint32_t  RES0_0:24;


    AS_MACRO RegCNTHCTL_EL2(uint32_t v)            {set(v);}
    AS_MACRO RegCNTHCTL_EL2& operator=(uint32_t v) {set(v);return *this;}
    AS_MACRO void set(uint32_t v) { *reinterpret_cast<uint32_t*>(this)=v;}
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<uint32_t*>(this);
    }


    AS_MACRO void dump()const
    {
        kout << "RegCNTHCTL_EL2: ";
            kout
                << "EL1PCTEN = " << EL1PCTEN << ", "
                << "EL1PCEN = " << EL1PCEN << ", "
                << "EVNTEN = " << EVNTEN << ", "
                << "EVNTDIR = " << EVNTDIR << ", "
                << "EVNTI = " << EVNTI << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }



    AS_MACRO static RegCNTHCTL_EL2 read()
    { 
        RegCNTHCTL_EL2 res;
        __asm__ __volatile__("mrs %0,CNTHCTL_EL2\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTHCTL_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,CNTHCTL_EL2\n\t":"=r"(*this));
        return *this;
    }

    AS_MACRO RegCNTHCTL_EL2 & setMandatoryFields()
    {
        EL1PCTEN = 0;
        EL1PCEN = 0;
        EVNTEN = 0;
        EVNTDIR = 0;
        EVNTI = 0;
        RES0_0 = 0;
        return *this;
    }
    
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTHCTL_EL2,%0\n\t"::"r"(*this));
    }

}__attribute__((packed));



class RegCNTKCTL_EL1 {
public:

            uint32_t  EL10PCTEN:1;
            uint32_t  EL0VCTEN:1;
            uint32_t  EVNTEN:1;
            uint32_t  EVNTDIR:1;
            uint32_t  EVNTI:4;
            uint32_t  EL0VTEN:1;
            uint32_t  EL0PTEN:1;
            uint32_t  RES0_0:22;


    AS_MACRO RegCNTKCTL_EL1(uint32_t v)            {set(v);}
    AS_MACRO RegCNTKCTL_EL1& operator=(uint32_t v) {set(v);return *this;}
    AS_MACRO void set(uint32_t v) { *reinterpret_cast<uint32_t*>(this)=v;}
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<uint32_t*>(this);
    }


    AS_MACRO void dump()const
    {
        kout << "RegCNTKCTL_EL1: ";
            kout
                << "EL10PCTEN = " << EL10PCTEN << ", "
                << "EL0VCTEN = " << EL0VCTEN << ", "
                << "EVNTEN = " << EVNTEN << ", "
                << "EVNTDIR = " << EVNTDIR << ", "
                << "EVNTI = " << EVNTI << ", "
                << "EL0VTEN = " << EL0VTEN << ", "
                << "EL0PTEN = " << EL0PTEN << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }



    AS_MACRO static RegCNTKCTL_EL1 read()
    { 
        RegCNTKCTL_EL1 res;
        __asm__ __volatile__("mrs %0,CNTKCTL_EL1\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTKCTL_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,CNTKCTL_EL1\n\t":"=r"(*this));
        return *this;
    }

    AS_MACRO RegCNTKCTL_EL1 & setMandatoryFields()
    {
        EL10PCTEN = 0;
        EL0VCTEN = 0;
        EVNTEN = 0;
        EVNTDIR = 0;
        EVNTI = 0;
        EL0VTEN = 0;
        EL0PTEN = 0;
        RES0_0 = 0;
        return *this;
    }
    
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTKCTL_EL1,%0\n\t"::"r"(*this));
    }

}__attribute__((packed));



class RegCNTP_CTL_EL0 {
public:

            uint32_t  ENABLE:1;
            uint32_t  IMASK:1;
            uint32_t  ISTATUS:1;
            uint32_t  RES0_0:29;


    AS_MACRO RegCNTP_CTL_EL0(uint32_t v)            {set(v);}
    AS_MACRO RegCNTP_CTL_EL0& operator=(uint32_t v) {set(v);return *this;}
    AS_MACRO void set(uint32_t v) { *reinterpret_cast<uint32_t*>(this)=v;}
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<uint32_t*>(this);
    }


    AS_MACRO void dump()const
    {
        kout << "RegCNTP_CTL_EL0: ";
            kout
                << "ENABLE = " << ENABLE << ", "
                << "IMASK = " << IMASK << ", "
                << "ISTATUS = " << ISTATUS << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }



    AS_MACRO static RegCNTP_CTL_EL0 read()
    { 
        RegCNTP_CTL_EL0 res;
        __asm__ __volatile__("mrs %0,CNTP_CTL_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTP_CTL_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTP_CTL_EL0\n\t":"=r"(*this));
        return *this;
    }

    AS_MACRO RegCNTP_CTL_EL0 & setMandatoryFields()
    {
        ENABLE = 0;
        IMASK = 0;
        ISTATUS = 0;
        RES0_0 = 0;
        return *this;
    }
    
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTP_CTL_EL0,%0\n\t"::"r"(*this));
    }

}__attribute__((packed));



class RegCNTP_CVAL_EL0 {
public:

            uint64_t  CompareValue:64;


    AS_MACRO RegCNTP_CVAL_EL0(uint64_t v)            {set(v);}
    AS_MACRO RegCNTP_CVAL_EL0& operator=(uint64_t v) {set(v);return *this;}
    AS_MACRO void set(uint64_t v) { *reinterpret_cast<uint64_t*>(this)=v;}
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<uint64_t*>(this);
    }


    AS_MACRO void dump()const
    {
        kout << "RegCNTP_CVAL_EL0: ";
            kout
                << "CompareValue = " << CompareValue << ", "
                << "\n";
    }



    AS_MACRO static RegCNTP_CVAL_EL0 read()
    { 
        RegCNTP_CVAL_EL0 res;
        __asm__ __volatile__("mrs %0,CNTP_CVAL_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTP_CVAL_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTP_CVAL_EL0\n\t":"=r"(*this));
        return *this;
    }

    AS_MACRO RegCNTP_CVAL_EL0 & setMandatoryFields()
    {
        CompareValue = 0;
        return *this;
    }
    
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTP_CVAL_EL0,%0\n\t"::"r"(*this));
    }

}__attribute__((packed));



class RegCNTP_TVAL_EL0 {
public:

            uint64_t  TimerValue:64;


    AS_MACRO RegCNTP_TVAL_EL0(uint64_t v)            {set(v);}
    AS_MACRO RegCNTP_TVAL_EL0& operator=(uint64_t v) {set(v);return *this;}
    AS_MACRO void set(uint64_t v) { *reinterpret_cast<uint64_t*>(this)=v;}
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<uint64_t*>(this);
    }


    AS_MACRO void dump()const
    {
        kout << "RegCNTP_TVAL_EL0: ";
            kout
                << "TimerValue = " << TimerValue << ", "
                << "\n";
    }



    AS_MACRO static RegCNTP_TVAL_EL0 read()
    { 
        RegCNTP_TVAL_EL0 res;
        __asm__ __volatile__("mrs %0,CNTP_TVAL_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTP_TVAL_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTP_TVAL_EL0\n\t":"=r"(*this));
        return *this;
    }

    AS_MACRO RegCNTP_TVAL_EL0 & setMandatoryFields()
    {
        TimerValue = 0;
        return *this;
    }
    
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTP_TVAL_EL0,%0\n\t"::"r"(*this));
    }

}__attribute__((packed));



class RegCNTPCT_EL0 {
public:

            uint64_t  PhysicalCount:64;


    AS_MACRO RegCNTPCT_EL0(uint64_t v)            {set(v);}
    AS_MACRO RegCNTPCT_EL0& operator=(uint64_t v) {set(v);return *this;}
    AS_MACRO void set(uint64_t v) { *reinterpret_cast<uint64_t*>(this)=v;}
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<uint64_t*>(this);
    }


    AS_MACRO void dump()const
    {
        kout << "RegCNTPCT_EL0: ";
            kout
                << "PhysicalCount = " << PhysicalCount << ", "
                << "\n";
    }



    AS_MACRO static RegCNTPCT_EL0 read()
    { 
        RegCNTPCT_EL0 res;
        __asm__ __volatile__("mrs %0,CNTPCT_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTPCT_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTPCT_EL0\n\t":"=r"(*this));
        return *this;
    }

    AS_MACRO RegCNTPCT_EL0 & setMandatoryFields()
    {
        PhysicalCount = 0;
        return *this;
    }
    
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTPCT_EL0,%0\n\t"::"r"(*this));
    }

}__attribute__((packed));



class RegCNTVCT_EL0 {
public:

            uint64_t  VirtualCountValue:64;


    AS_MACRO RegCNTVCT_EL0(uint64_t v)            {set(v);}
    AS_MACRO RegCNTVCT_EL0& operator=(uint64_t v) {set(v);return *this;}
    AS_MACRO void set(uint64_t v) { *reinterpret_cast<uint64_t*>(this)=v;}
    AS_MACRO uint64_t  get()const 
    {
        return *reinterpret_cast<uint64_t*>(this);
    }


    AS_MACRO void dump()const
    {
        kout << "RegCNTVCT_EL0: ";
            kout
                << "VirtualCountValue = " << VirtualCountValue << ", "
                << "\n";
    }



    AS_MACRO static RegCNTVCT_EL0 read()
    { 
        RegCNTVCT_EL0 res;
        __asm__ __volatile__("mrs %0,CNTVCT_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTVCT_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTVCT_EL0\n\t":"=r"(*this));
        return *this;
    }

    AS_MACRO RegCNTVCT_EL0 & setMandatoryFields()
    {
        VirtualCountValue = 0;
        return *this;
    }
    
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTVCT_EL0,%0\n\t"::"r"(*this));
    }

}__attribute__((packed));



class RegCNTV_CTL_EL0 {
public:

            uint32_t  ENABLE:1;
            uint32_t  IMASK:1;
            uint32_t  ISTATUS:1;
            uint32_t  RES0_0:29;


    AS_MACRO RegCNTV_CTL_EL0(uint32_t v)            {set(v);}
    AS_MACRO RegCNTV_CTL_EL0& operator=(uint32_t v) {set(v);return *this;}
    AS_MACRO void set(uint32_t v) { *reinterpret_cast<uint32_t*>(this)=v;}
    AS_MACRO uint32_t  get()const 
    {
        return *reinterpret_cast<uint32_t*>(this);
    }


    AS_MACRO void dump()const
    {
        kout << "RegCNTV_CTL_EL0: ";
            kout
                << "ENABLE = " << ENABLE << ", "
                << "IMASK = " << IMASK << ", "
                << "ISTATUS = " << ISTATUS << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }



    AS_MACRO static RegCNTV_CTL_EL0 read()
    { 
        RegCNTV_CTL_EL0 res;
        __asm__ __volatile__("mrs %0,CNTV_CTL_EL0\n\t":"=r"(res));
        return res;
    }
    AS_MACRO RegCNTV_CTL_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,CNTV_CTL_EL0\n\t":"=r"(*this));
        return *this;
    }

    AS_MACRO RegCNTV_CTL_EL0 & setMandatoryFields()
    {
        ENABLE = 0;
        IMASK = 0;
        ISTATUS = 0;
        RES0_0 = 0;
        return *this;
    }
    
    AS_MACRO void write()const
    {
        __asm__ __volatile__("msr CNTV_CTL_EL0,%0\n\t"::"r"(*this));
    }

}__attribute__((packed));

#endif //__INCLUDE_ARCH_COMMON_AARCH64_REGISTERS_TIMER_REGISTERS_H__
