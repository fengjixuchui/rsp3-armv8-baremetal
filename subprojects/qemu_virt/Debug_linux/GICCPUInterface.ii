# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/interrupt/GICCPUInterface.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "./cxx_macros.h" 1
# 32 "<command-line>" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/interrupt/GICCPUInterface.cpp"







# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICCPUInterface.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICCPUInterface.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h" 1







# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 1 3
# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 3
       
# 43 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 3






# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 1 3
# 229 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3

# 229 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 251 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 533 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/os_defines.h" 1 3
# 534 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 2 3


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/cpu_defines.h" 1 3
# 537 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 2 3
# 50 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 2 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 1 3 4
# 149 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 216 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 426 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 51 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 2 3


namespace std
{

  using ::max_align_t;
}
# 9 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h" 2
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 1 3
# 32 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 3
       
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 3
# 41 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint.h" 1 3 4
# 11 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint.h" 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint-gcc.h" 1 3 4
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint-gcc.h" 3 4
typedef signed char int8_t;


typedef short int int16_t;


typedef int int32_t;


typedef long int int64_t;


typedef unsigned char uint8_t;


typedef short unsigned int uint16_t;


typedef unsigned int uint32_t;


typedef long unsigned int uint64_t;




typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef short unsigned int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef long unsigned int uint_least64_t;



typedef int int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned int uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef long unsigned int uint_fast64_t;




typedef long int intptr_t;


typedef long unsigned int uintptr_t;




typedef long int intmax_t;
typedef long unsigned int uintmax_t;
# 12 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint.h" 2 3 4
# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 10 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h" 2
# 22 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h"

# 22 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h"
extern const char EMPTY_STR[1];



constexpr int UNIT_K=1024;
constexpr int KiB = UNIT_K;
constexpr int MiB = UNIT_K * KiB;
constexpr int GiB = UNIT_K * MiB;
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICCPUInterface.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICDefinitions.h" 1
# 15 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICDefinitions.h"
enum EOIMode{
 ack_priority_drop_and_deactivation=0,
 ack_priority_drop_no_deactivation=1,
};


using IntID = uint32_t;

constexpr IntID INT_IS_SECURE_GRP1=1020,
          INT_IS_NON_SECURE_GRP1=1021,
          INT_LEGACY=1022,
    INT_VIRTUAL_MAINTENCE=5,
    INT_HYP_TIMER=26,
    INT_VIRTUAL_TIMER=27,
    INT_S_PHY_TIMER=29,
       INT_NS_PHY_TIMER=30,
    INT_SPURIOUS=1023;


constexpr IntID INT_INPUT = 33;


constexpr uint8_t INT_IDLE_PRIORITY=0xFF;

template <template <int,class...> class T,int index,class ... Args>
__attribute__((always_inline)) inline T<index,Args...>& arrReg(typename T<index,Args...>::ScaleType reg[])
{
 return *reinterpret_cast<T<index,Args...>*>(reg+index);
}
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICCPUInterface.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/gicv3_registers.h" 1






# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h" 1
# 14 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h"
size_t printk(char ch);


size_t printk(const char *s);

size_t printk(const char *s,size_t n);


void flush();




# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/printk.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/printk.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/printk.h" 2
# 28 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h" 2
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/runtime_def.h" 1
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h" 2

class Output{
public:
 size_t print(const char *s,size_t len);
 size_t print(const char *s);
 Output & operator<<(char ch);

 Output & operator<<(uint8_t u);
 Output & operator<<(uint16_t u);
 Output & operator<<(uint32_t u);
 Output & operator<<(bool i);
 Output & operator<<(short i);
 Output & operator<<(int i);
 Output & operator<<(double d);
 Output & operator<<(const char *s);
 Output & operator<<(size_t i);
 Output & operator<<(const void *p);
 Output & operator<<(const volatile void *p);
 Output & flush();
};



extern Output kout;


constexpr size_t koutBufSize = 65;
extern char koutBuf[koutBufSize];
# 8 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/gicv3_registers.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h" 1
# 15 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h"
template <int Base>
class IntegerFormatter{
public:
 IntegerFormatter(size_t num);
 IntegerFormatter(const void *p);
 char *format()const;
private:
 size_t num;
};


using Hex=IntegerFormatter<16>;
using Dec=IntegerFormatter<10>;
using Bin=IntegerFormatter<2>;

template <int Base>
Output & operator<<(Output & out,const IntegerFormatter<Base> &hf);



# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic_util.h" 1
# 17 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic_util.h"
extern const char digitsMap[];



size_t itob(size_t i,char *dst,size_t size);
size_t itod(size_t i,char *dst,size_t size);
size_t itox(size_t i,char *dst,size_t size);

size_t itos(size_t i,unsigned int base,char *dst,size_t size);


uint64_t alignAhead(uint64_t d,uint64_t alignment);
uint64_t alignBackward(uint64_t d,uint64_t alignment);





void reverse(char *str,size_t size);



const char *strOffset(const char *p,size_t offset);

namespace{

 template <size_t bit,size_t ... bits>
 struct BitMaskStruct{
  static constexpr size_t value= BitMaskStruct<bit>::value|BitMaskStruct<bits...>::value;
 };
 template <size_t bit>
 struct BitMaskStruct<bit>{
  static constexpr size_t value=(1u<<bit);
 };

}




template <uint8_t...bit>
__attribute__((always_inline)) inline size_t bitMask()
{
 return BitMaskStruct<bit...>::value;
}


template <size_t ... bit>
__attribute__((always_inline)) inline constexpr size_t bitOnes()
{
 return BitMaskStruct<bit...>::value;
}

template <size_t ...bit>
__attribute__((always_inline)) inline constexpr size_t bitZeros()
{
 return ~(BitMaskStruct<bit...>::value);
}

template <size_t ...bit,class T>
__attribute__((always_inline)) inline T bitsSet(T t)
{
 return t | bitOnes<bit...>();
}

template <size_t ...bit,class T>
__attribute__((always_inline)) inline T bitsClear(T t)
{
 return (t & bitZeros<bit...>());
}


template <size_t ...bit,class T>
__attribute__((always_inline)) inline T bitsKept(T t)
{
 return (t & bitOnes<bit...>());
}
template <size_t ...bit,class T>
__attribute__((always_inline)) inline bool bitsAnySet(T t)
{
 return bitsKept<bit...>(t);
}
template <size_t ...bit,class T>
__attribute__((always_inline)) inline bool bitsNonSet(T t)
{
 return !bitsAnySet<bit...>(t);
}



template <size_t ...bitsAsOne,class VoidT,size_t ...bitsAsZero>
__attribute__((always_inline)) inline size_t bitsMix0()
{
 return bitsClear<bitsAsZero...>(bitsSet<bitsAsOne...>(static_cast<size_t>(0)));
}

template <size_t ...bitsAsOne,class VoidT,size_t ...bitsAsZero>
__attribute__((always_inline)) inline size_t bitsMix1()
{
 return bitsClear<bitsAsZero...>(bitsSet<bitsAsOne...>(static_cast<size_t>(0xffffffffffffffffUL)));
}

__attribute__((always_inline)) inline uint64_t bitMask(uint8_t bit)
{
 return (1u << bit);
}
template <uint64_t i>
__attribute__((always_inline)) inline uint64_t upperMaskBits()
{
 return 0xffffffffffffffff >> (64-i) << (64-i);
}
template <uint64_t i>
__attribute__((always_inline)) inline uint64_t lowerMaskBits()
{
 return 0xffffffffffffffff << (64-i) >> (64-i);
}

__attribute__((always_inline)) inline uint64_t upperMaskBits(uint64_t i)
{
 return 0xffffffffffffffff >> (64-i) << (64-i);
}

__attribute__((always_inline)) inline uint64_t lowerMaskBits(uint64_t i)
{
 return 0xffffffffffffffff << (64-i) >> (64-i);
}
__attribute__((always_inline)) inline uint64_t middleMaskBits(uint64_t lowerBound,uint64_t upperBound)
{

 return 0xffffffffffffffff >> lowerBound << (64 - upperBound - 1 + lowerBound) >> (64-upperBound -1);
}


template <class Type,class ValueType>
__attribute__((always_inline)) inline void setBits(Type & i, uint8_t lowerBound,uint8_t upperBound,ValueType v)
{

 i = (i & (~middleMaskBits(lowerBound, upperBound))) |((v & lowerMaskBits(upperBound - lowerBound + 1))<<lowerBound );
}
__attribute__((always_inline)) inline uint64_t getBits(uint64_t i, uint8_t lowerBound,uint8_t upperBound)
{
 return (i>>lowerBound)&lowerMaskBits(upperBound - lowerBound + 1);
}
# 175 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic_util.h"
template <class Type,class ValueType>
__attribute__((always_inline)) inline void setBit(Type & i,uint8_t index,ValueType v)
{
 setBits(i,index,index,v);
}
__attribute__((always_inline)) inline uint64_t getBit(uint64_t i,uint8_t index)
{
 return getBits(i,index,index);
}
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h" 2


template <int Base>
IntegerFormatter<Base>::IntegerFormatter(size_t num)
 :num(num){}

template <int Base>
IntegerFormatter<Base>::IntegerFormatter(const void *p)
 :num(reinterpret_cast<size_t>(p)){}

template <int Base>
char *IntegerFormatter<Base>::format()const
{
 itos(num, Base, koutBuf, koutBufSize);
 return koutBuf;
}

template <int Base>
Output & operator<<(Output &out,const IntegerFormatter<Base> &hf)
{
 out << hf.format();
 return out;
}
# 36 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h" 2
# 9 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/gicv3_registers.h" 2

class RegICC_BPR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
            uint32_t BinaryPoint:3;
            uint32_t RES0_0:29;

    __attribute__((always_inline)) inline RegICC_BPR_EL1_BASE & setMandatoryFields()
    {
        BinaryPoint = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_BPR_EL1_BASE: ";
            kout
                << "BinaryPoint = " << BinaryPoint << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_BPR_EL1_BASE*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_BPR_EL1_BASE make(uint32_t val)
    {
        RegICC_BPR_EL1_BASE res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
}__attribute__((packed));


template <int grp=0>
class RegICC_BPR_EL1
    :public RegICC_BPR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    static_assert(grp==0,"group must be 0");
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_BPR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_BPR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_BPR_EL1 copy()const volatile
    {
     RegICC_BPR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_BPR_EL1 copy()const
    {
     RegICC_BPR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_BPR_EL1 make(uint32_t val)
    {
        RegICC_BPR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_BPR_EL1 read()
    {
        RegICC_BPR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c8_3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_BPR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c8_3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c8_3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


template <>
class RegICC_BPR_EL1<1>
    :public RegICC_BPR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_BPR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_BPR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_BPR_EL1 copy()const volatile
    {
     RegICC_BPR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_BPR_EL1 copy()const
    {
     RegICC_BPR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_BPR_EL1 make(uint32_t val)
    {
        RegICC_BPR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_BPR_EL1 read()
    {
        RegICC_BPR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_BPR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c12_3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_CTLR_EL3
{
public:
    using ScaleType=uint32_t;
            uint32_t CBPR_EL1S:1;
            uint32_t CBPR_EL1NS:1;
            uint32_t EOImode_EL3:1;
            uint32_t EOImode_EL1S:1;
            uint32_t EOImode_EL1NS:1;
            uint32_t RM:1;
            uint32_t PMHE:1;
            uint32_t RES0_0:1;
            uint32_t PRIbits:3;
            uint32_t IDbits:3;
            uint32_t SEIS:1;
            uint32_t A3V:1;
            uint32_t RES0_1:1;
            uint32_t nDS:1;
            uint32_t RSS:1;
            uint32_t RES0_2:13;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_CTLR_EL3& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_CTLR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_CTLR_EL3 & setMandatoryFields()
    {
        CBPR_EL1S = 0;
        CBPR_EL1NS = 0;
        EOImode_EL3 = 0;
        EOImode_EL1S = 0;
        EOImode_EL1NS = 0;
        RM = 0;
        PMHE = 0;
        RES0_0 = 0;
        PRIbits = 0;
        IDbits = 0;
        SEIS = 0;
        A3V = 0;
        RES0_1 = 0;
        nDS = 0;
        RSS = 0;
        RES0_2 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegICC_CTLR_EL3 copy()const volatile
    {
     RegICC_CTLR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_CTLR_EL3 copy()const
    {
     RegICC_CTLR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_CTLR_EL3: ";
            kout
                << "CBPR_EL1S = " << CBPR_EL1S << ", "
                << "CBPR_EL1NS = " << CBPR_EL1NS << ", "
                << "EOImode_EL3 = " << EOImode_EL3 << ", "
                << "EOImode_EL1S = " << EOImode_EL1S << ", "
                << "EOImode_EL1NS = " << EOImode_EL1NS << ", "
                << "RM = " << RM << ", "
                << "PMHE = " << PMHE << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "PRIbits = " << PRIbits << ", "
                << "IDbits = " << IDbits << ", "
                << "SEIS = " << SEIS << ", "
                << "A3V = " << A3V << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "nDS = " << nDS << ", "
                << "RSS = " << RSS << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_CTLR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_CTLR_EL3 make(uint32_t val)
    {
        RegICC_CTLR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_CTLR_EL3 read()
    {
        RegICC_CTLR_EL3 res;
        __asm__ __volatile__("mrs %0,s3_6_c12_c12_4\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_CTLR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,s3_6_c12_c12_4\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_6_c12_c12_4,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_CTLR_EL1
{
public:
    using ScaleType=uint32_t;
    enum { INTIDBits16=0b000,INTIDBits24=0b001 };
            uint32_t CBPR:1;
            uint32_t EOImode:1;
            uint32_t RES0_0:4;
            uint32_t PMHE:1;
            uint32_t RES0_1:1;
            uint32_t PRIbits:3;
            uint32_t IDbits:3;
            uint32_t SEIS:1;
            uint32_t A3V:1;
            uint32_t RES0_2:2;
            uint32_t RSS:1;
            uint32_t RES0_3:13;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_CTLR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_CTLR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_CTLR_EL1 & setMandatoryFields()
    {
        CBPR = 0;
        EOImode = 0;
        RES0_0 = 0;
        PMHE = 0;
        RES0_1 = 0;
        PRIbits = 0;
        IDbits = 0;
        SEIS = 0;
        A3V = 0;
        RES0_2 = 0;
        RSS = 0;
        RES0_3 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegICC_CTLR_EL1 copy()const volatile
    {
     RegICC_CTLR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_CTLR_EL1 copy()const
    {
     RegICC_CTLR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_CTLR_EL1: ";
            kout
                << "CBPR = " << CBPR << ", "
                << "EOImode = " << EOImode << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "PMHE = " << PMHE << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "PRIbits = " << PRIbits << ", "
                << "IDbits = " << IDbits << ", "
                << "SEIS = " << SEIS << ", "
                << "A3V = " << A3V << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "RSS = " << RSS << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_CTLR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_CTLR_EL1 make(uint32_t val)
    {
        RegICC_CTLR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_CTLR_EL1 read()
    {
        RegICC_CTLR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_4\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_CTLR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_4\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c12_4,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_DIR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t INTID:24;
            uint32_t RES0_0:8;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_DIR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_DIR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_DIR_EL1 & setMandatoryFields()
    {
        INTID = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegICC_DIR_EL1 copy()const volatile
    {
     RegICC_DIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_DIR_EL1 copy()const
    {
     RegICC_DIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_DIR_EL1: ";
            kout
                << "INTID = " << INTID << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_DIR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_DIR_EL1 make(uint32_t val)
    {
        RegICC_DIR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_DIR_EL1 read()
    {
        RegICC_DIR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c11_1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_DIR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c11_1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c11_1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_EOIR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
            uint32_t INTID:24;
            uint32_t RES0_0:8;

    __attribute__((always_inline)) inline RegICC_EOIR_EL1_BASE & setMandatoryFields()
    {
        INTID = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_EOIR_EL1_BASE: ";
            kout
                << "INTID = " << INTID << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_EOIR_EL1_BASE*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_EOIR_EL1_BASE make(uint32_t val)
    {
        RegICC_EOIR_EL1_BASE res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
}__attribute__((packed));


template <int grp=0>
class RegICC_EOIR_EL1
    :public RegICC_EOIR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    static_assert(grp==0,"group must be 0");
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_EOIR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_EOIR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_EOIR_EL1 copy()const volatile
    {
     RegICC_EOIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_EOIR_EL1 copy()const
    {
     RegICC_EOIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_EOIR_EL1 make(uint32_t val)
    {
        RegICC_EOIR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_EOIR_EL1 read()
    {
        RegICC_EOIR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c8_1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_EOIR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c8_1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c8_1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


template <>
class RegICC_EOIR_EL1<1>
    :public RegICC_EOIR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_EOIR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_EOIR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_EOIR_EL1 copy()const volatile
    {
     RegICC_EOIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_EOIR_EL1 copy()const
    {
     RegICC_EOIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_EOIR_EL1 make(uint32_t val)
    {
        RegICC_EOIR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_EOIR_EL1 read()
    {
        RegICC_EOIR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_EOIR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c12_1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_HPPIR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
            uint32_t INTID:24;
            uint32_t RES0_0:8;

    __attribute__((always_inline)) inline RegICC_HPPIR_EL1_BASE & setMandatoryFields()
    {
        INTID = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_HPPIR_EL1_BASE: ";
            kout
                << "INTID = " << INTID << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_HPPIR_EL1_BASE*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_HPPIR_EL1_BASE make(uint32_t val)
    {
        RegICC_HPPIR_EL1_BASE res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
}__attribute__((packed));


template <int grp=0>
class RegICC_HPPIR_EL1
    :public RegICC_HPPIR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    static_assert(grp==0,"group must be 0");
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_HPPIR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_HPPIR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_HPPIR_EL1 copy()const volatile
    {
     RegICC_HPPIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_HPPIR_EL1 copy()const
    {
     RegICC_HPPIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_HPPIR_EL1 make(uint32_t val)
    {
        RegICC_HPPIR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_HPPIR_EL1 read()
    {
        RegICC_HPPIR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c8_2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_HPPIR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c8_2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c8_2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


template <>
class RegICC_HPPIR_EL1<1>
    :public RegICC_HPPIR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
            uint32_t INTID:24;
            uint32_t RES0_0:8;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_HPPIR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_HPPIR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_HPPIR_EL1 copy()const volatile
    {
     RegICC_HPPIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_HPPIR_EL1 copy()const
    {
     RegICC_HPPIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_HPPIR_EL1 make(uint32_t val)
    {
        RegICC_HPPIR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_HPPIR_EL1 read()
    {
        RegICC_HPPIR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_HPPIR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c12_2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_IAR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
            uint32_t INTID:24;
            uint32_t RES0_0:8;

    __attribute__((always_inline)) inline RegICC_IAR_EL1_BASE & setMandatoryFields()
    {
        INTID = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_IAR_EL1_BASE: ";
            kout
                << "INTID = " << INTID << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_IAR_EL1_BASE*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_IAR_EL1_BASE make(uint32_t val)
    {
        RegICC_IAR_EL1_BASE res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
}__attribute__((packed));


template <int grp=0>
class RegICC_IAR_EL1
    :public RegICC_IAR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    static_assert(grp==0,"group must be 0");
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_IAR_EL1 make(uint32_t val)
    {
        RegICC_IAR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_IAR_EL1 read()
    {
        RegICC_IAR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c8_0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_IAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c8_0\n\t":"=r"(*this));
        return *this;
    }
}__attribute__((packed));


template <>
class RegICC_IAR_EL1<1>
    :public RegICC_IAR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_IAR_EL1 make(uint32_t val)
    {
        RegICC_IAR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_IAR_EL1 read()
    {
        RegICC_IAR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_IAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_0\n\t":"=r"(*this));
        return *this;
    }
}__attribute__((packed));


class RegICC_IGRPEN_EL1_BASE
{
public:
    using ScaleType=uint32_t;
            uint32_t Enable:1;
            uint32_t RES0_0:31;

    __attribute__((always_inline)) inline RegICC_IGRPEN_EL1_BASE & setMandatoryFields()
    {
        Enable = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_IGRPEN_EL1_BASE: ";
            kout
                << "Enable = " << Enable << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_IGRPEN_EL1_BASE*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_IGRPEN_EL1_BASE make(uint32_t val)
    {
        RegICC_IGRPEN_EL1_BASE res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
}__attribute__((packed));


template <int grp=0>
class RegICC_IGRPEN_EL1
    :public RegICC_IGRPEN_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    static_assert(grp==0,"group must be 0");
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_IGRPEN_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_IGRPEN_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_IGRPEN_EL1 copy()const volatile
    {
     RegICC_IGRPEN_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_IGRPEN_EL1 copy()const
    {
     RegICC_IGRPEN_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_IGRPEN_EL1 make(uint32_t val)
    {
        RegICC_IGRPEN_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_IGRPEN_EL1 read()
    {
        RegICC_IGRPEN_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_6\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_IGRPEN_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_6\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c12_6,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


template <>
class RegICC_IGRPEN_EL1<1>
    :public RegICC_IGRPEN_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_IGRPEN_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_IGRPEN_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_IGRPEN_EL1 copy()const volatile
    {
     RegICC_IGRPEN_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_IGRPEN_EL1 copy()const
    {
     RegICC_IGRPEN_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_IGRPEN_EL1 make(uint32_t val)
    {
        RegICC_IGRPEN_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_IGRPEN_EL1 read()
    {
        RegICC_IGRPEN_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_7\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_IGRPEN_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_7\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c12_7,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_IGRPEN1_EL3
{
public:
    using ScaleType=uint32_t;
            uint32_t EnableGrp1NS:1;
            uint32_t EnableGrp1S:1;
            uint32_t RES0_0:30;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_IGRPEN1_EL3& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_IGRPEN1_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_IGRPEN1_EL3 & setMandatoryFields()
    {
        EnableGrp1NS = 0;
        EnableGrp1S = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegICC_IGRPEN1_EL3 copy()const volatile
    {
     RegICC_IGRPEN1_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_IGRPEN1_EL3 copy()const
    {
     RegICC_IGRPEN1_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_IGRPEN1_EL3: ";
            kout
                << "EnableGrp1NS = " << EnableGrp1NS << ", "
                << "EnableGrp1S = " << EnableGrp1S << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_IGRPEN1_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_IGRPEN1_EL3 make(uint32_t val)
    {
        RegICC_IGRPEN1_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_IGRPEN1_EL3 read()
    {
        RegICC_IGRPEN1_EL3 res;
        __asm__ __volatile__("mrs %0,s3_6_c12_c12_7\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_IGRPEN1_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,s3_6_c12_c12_7\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_6_c12_c12_7,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_PMR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t Priortiy:8;
            uint32_t RES0_0:24;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_PMR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_PMR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_PMR_EL1 & setMandatoryFields()
    {
        Priortiy = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegICC_PMR_EL1 copy()const volatile
    {
     RegICC_PMR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_PMR_EL1 copy()const
    {
     RegICC_PMR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_PMR_EL1: ";
            kout
                << "Priortiy = " << Priortiy << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_PMR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_PMR_EL1 make(uint32_t val)
    {
        RegICC_PMR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_PMR_EL1 read()
    {
        RegICC_PMR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c4_c6_0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_PMR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c4_c6_0\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c4_c6_0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_RPR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t Priortiy:8;
            uint32_t RES0_0:24;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_RPR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_RPR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_RPR_EL1 & setMandatoryFields()
    {
        Priortiy = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegICC_RPR_EL1 copy()const volatile
    {
     RegICC_RPR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_RPR_EL1 copy()const
    {
     RegICC_RPR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_RPR_EL1: ";
            kout
                << "Priortiy = " << Priortiy << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_RPR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_RPR_EL1 make(uint32_t val)
    {
        RegICC_RPR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_RPR_EL1 read()
    {
        RegICC_RPR_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c11_3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_RPR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c11_3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c11_3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_SGIR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    enum IRMmode { ByAffinity=0,AllNoSelf=1 };
            uint32_t TargetList:16;
            uint32_t Aff1:8;
            uint32_t INTID:4;
            uint32_t RES0_0:4;
            uint32_t Aff2:8;
            uint32_t IRM:1;
            uint32_t RES0_1:3;
            uint32_t RS:4;
            uint32_t Aff3:8;
            uint32_t RES0_2:8;

    __attribute__((always_inline)) inline RegICC_SGIR_EL1_BASE & setMandatoryFields()
    {
        TargetList = 0;
        Aff1 = 0;
        INTID = 0;
        RES0_0 = 0;
        Aff2 = 0;
        IRM = 0;
        RES0_1 = 0;
        RS = 0;
        Aff3 = 0;
        RES0_2 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_SGIR_EL1_BASE: ";
            kout
                << "TargetList = " << TargetList << ", "
                << "Aff1 = " << Aff1 << ", "
                << "INTID = " << INTID << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "Aff2 = " << Aff2 << ", "
                << "IRM = " << IRM << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "RS = " << RS << ", "
                << "Aff3 = " << Aff3 << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_SGIR_EL1_BASE*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_SGIR_EL1_BASE make(uint32_t val)
    {
        RegICC_SGIR_EL1_BASE res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
}__attribute__((packed));


template <int grp=0>
class RegICC_SGIR_EL1
    :public RegICC_SGIR_EL1_BASE
{
public:
    using ScaleType=uint32_t;
    static_assert(grp==0,"group must be 0");

    __attribute__((always_inline)) inline RegICC_SGIR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_SGIR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_SGIR_EL1 make(uint32_t val)
    {
        RegICC_SGIR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c11_7,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


template <>
class RegICC_SGIR_EL1<1>
    :public RegICC_SGIR_EL1_BASE
{
public:
    using ScaleType=uint32_t;

    __attribute__((always_inline)) inline RegICC_SGIR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_SGIR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_SGIR_EL1 make(uint32_t val)
    {
        RegICC_SGIR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c11_5,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_SRE_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t SRE:1;
            uint32_t DFB:1;
            uint32_t DIB:1;
            uint32_t RES0_0:29;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_SRE_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_SRE_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_SRE_EL1 & setMandatoryFields()
    {
        SRE = 0;
        DFB = 0;
        DIB = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegICC_SRE_EL1 copy()const volatile
    {
     RegICC_SRE_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_SRE_EL1 copy()const
    {
     RegICC_SRE_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_SRE_EL1: ";
            kout
                << "SRE = " << SRE << ", "
                << "DFB = " << DFB << ", "
                << "DIB = " << DIB << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_SRE_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_SRE_EL1 make(uint32_t val)
    {
        RegICC_SRE_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_SRE_EL1 read()
    {
        RegICC_SRE_EL1 res;
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_5\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_SRE_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,s3_0_c12_c12_5\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_0_c12_c12_5,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_SRE_EL2
{
public:
    using ScaleType=uint32_t;
            uint32_t SRE:1;
            uint32_t DFB:1;
            uint32_t DIB:1;
            uint32_t RES0_0:29;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_SRE_EL2& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_SRE_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_SRE_EL2 & setMandatoryFields()
    {
        SRE = 0;
        DFB = 0;
        DIB = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegICC_SRE_EL2 copy()const volatile
    {
     RegICC_SRE_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_SRE_EL2 copy()const
    {
     RegICC_SRE_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_SRE_EL2: ";
            kout
                << "SRE = " << SRE << ", "
                << "DFB = " << DFB << ", "
                << "DIB = " << DIB << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_SRE_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_SRE_EL2 make(uint32_t val)
    {
        RegICC_SRE_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_SRE_EL2 read()
    {
        RegICC_SRE_EL2 res;
        __asm__ __volatile__("mrs %0,s3_4_c12_c9_5\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_SRE_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,s3_4_c12_c9_5\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_4_c12_c9_5,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegICC_SRE_EL3
{
public:
    using ScaleType=uint32_t;
            uint32_t SRE:1;
            uint32_t DFB:1;
            uint32_t DIB:1;
            uint32_t RES0_0:29;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegICC_SRE_EL3& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegICC_SRE_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegICC_SRE_EL3 & setMandatoryFields()
    {
        SRE = 0;
        DFB = 0;
        DIB = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegICC_SRE_EL3 copy()const volatile
    {
     RegICC_SRE_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegICC_SRE_EL3 copy()const
    {
     RegICC_SRE_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegICC_SRE_EL3: ";
            kout
                << "SRE = " << SRE << ", "
                << "DFB = " << DFB << ", "
                << "DIB = " << DIB << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegICC_SRE_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegICC_SRE_EL3 make(uint32_t val)
    {
        RegICC_SRE_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegICC_SRE_EL3 read()
    {
        RegICC_SRE_EL3 res;
        __asm__ __volatile__("mrs %0,s3_6_c12_c12_5\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegICC_SRE_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,s3_6_c12_c12_5\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr s3_6_c12_c12_5,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegGICR_CTLR
{
public:
    using ScaleType=uint32_t;
            uint32_t EnableLPIs:1;
            uint32_t RES0_0:2;
            uint32_t RWP:1;
            uint32_t RES0_1:20;
            uint32_t DPG0:1;
            uint32_t DPG1NS:1;
            uint32_t DPG1S:1;
            uint32_t RES0_2:4;
            uint32_t UWP:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_CTLR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_CTLR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_CTLR & setMandatoryFields()
    {
        EnableLPIs = 0;
        RES0_0 = 0;
        RWP = 0;
        RES0_1 = 0;
        DPG0 = 0;
        DPG1NS = 0;
        DPG1S = 0;
        RES0_2 = 0;
        UWP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_CTLR copy()const volatile
    {
     RegGICR_CTLR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_CTLR copy()const
    {
     RegGICR_CTLR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_CTLR: ";
            kout
                << "EnableLPIs = " << EnableLPIs << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "RWP = " << RWP << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "DPG0 = " << DPG0 << ", "
                << "DPG1NS = " << DPG1NS << ", "
                << "DPG1S = " << DPG1S << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "UWP = " << UWP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_CTLR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_CTLR make(uint32_t val)
    {
        RegGICR_CTLR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_CTLR read(void* addr)
    {
        return *reinterpret_cast<RegGICR_CTLR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_CTLR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_CTLR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_CTLR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_CTLR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_CTLR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_CTLR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_ICACTIVER0
{
public:
    using ScaleType=uint32_t;
            uint32_t Actives:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_ICACTIVER0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_ICACTIVER0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_ICACTIVER0 & setMandatoryFields()
    {
        Actives = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_ICACTIVER0 copy()const volatile
    {
     RegGICR_ICACTIVER0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_ICACTIVER0 copy()const
    {
     RegGICR_ICACTIVER0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_ICACTIVER0: ";
            kout
                << "Actives = " << Hex(Actives) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_ICACTIVER0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_ICACTIVER0 make(uint32_t val)
    {
        RegGICR_ICACTIVER0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_ICACTIVER0 read(void* addr)
    {
        return *reinterpret_cast<RegGICR_ICACTIVER0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ICACTIVER0& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_ICACTIVER0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ICACTIVER0& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_ICACTIVER0 read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_ICACTIVER0*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_ICACTIVER0*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_ICENABLER0
{
public:
    using ScaleType=uint32_t;
            uint32_t ClearEnables:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_ICENABLER0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_ICENABLER0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_ICENABLER0 & setMandatoryFields()
    {
        ClearEnables = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_ICENABLER0 copy()const volatile
    {
     RegGICR_ICENABLER0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_ICENABLER0 copy()const
    {
     RegGICR_ICENABLER0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_ICENABLER0: ";
            kout
                << "ClearEnables = " << Hex(ClearEnables) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_ICENABLER0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_ICENABLER0 make(uint32_t val)
    {
        RegGICR_ICENABLER0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_ICENABLER0 read(void* addr)
    {
        return *reinterpret_cast<RegGICR_ICENABLER0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ICENABLER0& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_ICENABLER0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ICENABLER0& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_ICENABLER0 read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_ICENABLER0*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_ICENABLER0*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_ICFGR0
{
public:
    using ScaleType=uint32_t;
            uint32_t Configs:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_ICFGR0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_ICFGR0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_ICFGR0 & setMandatoryFields()
    {
        Configs = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_ICFGR0 copy()const volatile
    {
     RegGICR_ICFGR0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_ICFGR0 copy()const
    {
     RegGICR_ICFGR0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_ICFGR0: ";
            kout
                << "Configs = " << Hex(Configs) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_ICFGR0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_ICFGR0 make(uint32_t val)
    {
        RegGICR_ICFGR0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_ICFGR0 read(void* addr)
    {
        return *reinterpret_cast<RegGICR_ICFGR0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ICFGR0& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_ICFGR0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ICFGR0& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_ICFGR0 read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_ICFGR0*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_ICFGR0*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_ICFGR1
{
public:
    using ScaleType=uint32_t;
            uint32_t Configs:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_ICFGR1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_ICFGR1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_ICFGR1 & setMandatoryFields()
    {
        Configs = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_ICFGR1 copy()const volatile
    {
     RegGICR_ICFGR1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_ICFGR1 copy()const
    {
     RegGICR_ICFGR1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_ICFGR1: ";
            kout
                << "Configs = " << Hex(Configs) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_ICFGR1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_ICFGR1 make(uint32_t val)
    {
        RegGICR_ICFGR1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_ICFGR1 read(void* addr)
    {
        return *reinterpret_cast<RegGICR_ICFGR1*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ICFGR1& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_ICFGR1*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ICFGR1& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_ICFGR1 read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_ICFGR1*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_ICFGR1*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_ICPENDR0
{
public:
    using ScaleType=uint32_t;
            uint32_t Clears:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_ICPENDR0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_ICPENDR0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_ICPENDR0 & setMandatoryFields()
    {
        Clears = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_ICPENDR0 copy()const volatile
    {
     RegGICR_ICPENDR0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_ICPENDR0 copy()const
    {
     RegGICR_ICPENDR0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_ICPENDR0: ";
            kout
                << "Clears = " << Clears << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_ICPENDR0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_ICPENDR0 make(uint32_t val)
    {
        RegGICR_ICPENDR0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_ICPENDR0 read(void* addr)
    {
        return *reinterpret_cast<RegGICR_ICPENDR0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ICPENDR0& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_ICPENDR0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ICPENDR0& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_ICPENDR0 read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_ICPENDR0*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_ICPENDR0*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_IGROUPR0
{
public:
    using ScaleType=uint32_t;
            uint32_t InGrp:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_IGROUPR0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_IGROUPR0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_IGROUPR0 & setMandatoryFields()
    {
        InGrp = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_IGROUPR0 copy()const volatile
    {
     RegGICR_IGROUPR0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_IGROUPR0 copy()const
    {
     RegGICR_IGROUPR0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_IGROUPR0: ";
            kout
                << "InGrp = " << InGrp << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_IGROUPR0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_IGROUPR0 make(uint32_t val)
    {
        RegGICR_IGROUPR0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_IGROUPR0 read(void* addr)
    {
        return *reinterpret_cast<RegGICR_IGROUPR0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_IGROUPR0& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_IGROUPR0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_IGROUPR0& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_IGROUPR0 read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_IGROUPR0*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_IGROUPR0*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_IIDR
{
public:
    using ScaleType=uint32_t;
            uint32_t Implementer:12;
            uint32_t Revision:4;
            uint32_t Variant:4;
            uint32_t RES0_0:4;
            uint32_t ProductID:8;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_IIDR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_IIDR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_IIDR & setMandatoryFields()
    {
        Implementer = 0;
        Revision = 0;
        Variant = 0;
        RES0_0 = 0;
        ProductID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_IIDR copy()const volatile
    {
     RegGICR_IIDR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_IIDR copy()const
    {
     RegGICR_IIDR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_IIDR: ";
            kout
                << "Implementer = " << Implementer << ", "
                << "Revision = " << Revision << ", "
                << "Variant = " << Variant << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "ProductID = " << ProductID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_IIDR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_IIDR make(uint32_t val)
    {
        RegGICR_IIDR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_IIDR read(void* addr)
    {
        return *reinterpret_cast<RegGICR_IIDR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_IIDR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_IIDR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_IIDR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_IIDR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_IIDR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_IIDR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_IPRIORITYR
{
public:
    using ScaleType=uint32_t;
            uint32_t p0:8;
            uint32_t p1:8;
            uint32_t p2:8;
            uint32_t p3:8;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_IPRIORITYR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_IPRIORITYR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_IPRIORITYR & setMandatoryFields()
    {
        p0 = 0;
        p1 = 0;
        p2 = 0;
        p3 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_IPRIORITYR copy()const volatile
    {
     RegGICR_IPRIORITYR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_IPRIORITYR copy()const
    {
     RegGICR_IPRIORITYR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_IPRIORITYR: ";
            kout
                << "p0 = " << p0 << ", "
                << "p1 = " << p1 << ", "
                << "p2 = " << p2 << ", "
                << "p3 = " << p3 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_IPRIORITYR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_IPRIORITYR make(uint32_t val)
    {
        RegGICR_IPRIORITYR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_IPRIORITYR read(void* addr)
    {
        return *reinterpret_cast<RegGICR_IPRIORITYR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_IPRIORITYR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_IPRIORITYR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_IPRIORITYR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_IPRIORITYR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_IPRIORITYR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_IPRIORITYR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_ISACTIVER0
{
public:
    using ScaleType=uint32_t;
            uint32_t Actives:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_ISACTIVER0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_ISACTIVER0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_ISACTIVER0 & setMandatoryFields()
    {
        Actives = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_ISACTIVER0 copy()const volatile
    {
     RegGICR_ISACTIVER0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_ISACTIVER0 copy()const
    {
     RegGICR_ISACTIVER0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_ISACTIVER0: ";
            kout
                << "Actives = " << Hex(Actives) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_ISACTIVER0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_ISACTIVER0 make(uint32_t val)
    {
        RegGICR_ISACTIVER0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_ISACTIVER0 read(void* addr)
    {
        return *reinterpret_cast<RegGICR_ISACTIVER0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ISACTIVER0& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_ISACTIVER0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ISACTIVER0& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_ISACTIVER0 read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_ISACTIVER0*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_ISACTIVER0*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_ISENABLER0
{
public:
    using ScaleType=uint32_t;
            uint32_t Enables:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_ISENABLER0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_ISENABLER0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_ISENABLER0 & setMandatoryFields()
    {
        Enables = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_ISENABLER0 copy()const volatile
    {
     RegGICR_ISENABLER0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_ISENABLER0 copy()const
    {
     RegGICR_ISENABLER0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_ISENABLER0: ";
            kout
                << "Enables = " << Hex(Enables) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_ISENABLER0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_ISENABLER0 make(uint32_t val)
    {
        RegGICR_ISENABLER0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_ISENABLER0 read(void* addr)
    {
        return *reinterpret_cast<RegGICR_ISENABLER0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ISENABLER0& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_ISENABLER0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ISENABLER0& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_ISENABLER0 read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_ISENABLER0*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_ISENABLER0*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_ISPENDR0
{
public:
    using ScaleType=uint32_t;
            uint32_t Pendings:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_ISPENDR0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_ISPENDR0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_ISPENDR0 & setMandatoryFields()
    {
        Pendings = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_ISPENDR0 copy()const volatile
    {
     RegGICR_ISPENDR0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_ISPENDR0 copy()const
    {
     RegGICR_ISPENDR0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_ISPENDR0: ";
            kout
                << "Pendings = " << Hex(Pendings) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_ISPENDR0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_ISPENDR0 make(uint32_t val)
    {
        RegGICR_ISPENDR0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_ISPENDR0 read(void* addr)
    {
        return *reinterpret_cast<RegGICR_ISPENDR0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ISPENDR0& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_ISPENDR0*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_ISPENDR0& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_ISPENDR0 read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_ISPENDR0*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_ISPENDR0*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_NSACR
{
public:
    using ScaleType=uint32_t;
            uint32_t NSAccess0:2;
            uint32_t NSAccess1:2;
            uint32_t NSAccess2:2;
            uint32_t NSAccess3:2;
            uint32_t NSAccess4:2;
            uint32_t NSAccess5:2;
            uint32_t NSAccess6:2;
            uint32_t NSAccess7:2;
            uint32_t NSAccess8:2;
            uint32_t NSAccess9:2;
            uint32_t NSAccess10:2;
            uint32_t NSAccess11:2;
            uint32_t NSAccess12:2;
            uint32_t NSAccess13:2;
            uint32_t NSAccess14:2;
            uint32_t NSAccess15:2;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_NSACR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_NSACR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_NSACR & setMandatoryFields()
    {
        NSAccess0 = 0;
        NSAccess1 = 0;
        NSAccess2 = 0;
        NSAccess3 = 0;
        NSAccess4 = 0;
        NSAccess5 = 0;
        NSAccess6 = 0;
        NSAccess7 = 0;
        NSAccess8 = 0;
        NSAccess9 = 0;
        NSAccess10 = 0;
        NSAccess11 = 0;
        NSAccess12 = 0;
        NSAccess13 = 0;
        NSAccess14 = 0;
        NSAccess15 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_NSACR copy()const volatile
    {
     RegGICR_NSACR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_NSACR copy()const
    {
     RegGICR_NSACR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_NSACR: ";
            kout
                << "NSAccess0 = " << NSAccess0 << ", "
                << "NSAccess1 = " << NSAccess1 << ", "
                << "NSAccess2 = " << NSAccess2 << ", "
                << "NSAccess3 = " << NSAccess3 << ", "
                << "NSAccess4 = " << NSAccess4 << ", "
                << "NSAccess5 = " << NSAccess5 << ", "
                << "NSAccess6 = " << NSAccess6 << ", "
                << "NSAccess7 = " << NSAccess7 << ", "
                << "NSAccess8 = " << NSAccess8 << ", "
                << "NSAccess9 = " << NSAccess9 << ", "
                << "NSAccess10 = " << NSAccess10 << ", "
                << "NSAccess11 = " << NSAccess11 << ", "
                << "NSAccess12 = " << NSAccess12 << ", "
                << "NSAccess13 = " << NSAccess13 << ", "
                << "NSAccess14 = " << NSAccess14 << ", "
                << "NSAccess15 = " << NSAccess15 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_NSACR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_NSACR make(uint32_t val)
    {
        RegGICR_NSACR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_NSACR read(void* addr)
    {
        return *reinterpret_cast<RegGICR_NSACR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_NSACR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_NSACR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_NSACR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_NSACR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_NSACR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_NSACR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_STATUSR
{
public:
    using ScaleType=uint32_t;
            uint32_t RRD:1;
            uint32_t WRD:1;
            uint32_t RWOD:1;
            uint32_t WROD:1;
            uint32_t RES0_0:28;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_STATUSR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_STATUSR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_STATUSR & setMandatoryFields()
    {
        RRD = 0;
        WRD = 0;
        RWOD = 0;
        WROD = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_STATUSR copy()const volatile
    {
     RegGICR_STATUSR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_STATUSR copy()const
    {
     RegGICR_STATUSR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_STATUSR: ";
            kout
                << "RRD = " << RRD << ", "
                << "WRD = " << WRD << ", "
                << "RWOD = " << RWOD << ", "
                << "WROD = " << WROD << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_STATUSR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_STATUSR make(uint32_t val)
    {
        RegGICR_STATUSR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_STATUSR read(void* addr)
    {
        return *reinterpret_cast<RegGICR_STATUSR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_STATUSR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_STATUSR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_STATUSR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_STATUSR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_STATUSR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_STATUSR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICR_TYPER
{
public:
    using ScaleType=uint64_t;
            uint64_t PLPIS:1;
            uint64_t VLPIS:1;
            uint64_t RES0_0:1;
            uint64_t DirectLPI:1;
            uint64_t Last:1;
            uint64_t DPGR:1;
            uint64_t RES0_1:2;
            uint64_t ProcessorNumber:16;
            uint64_t CommonLPIAff:2;
            uint64_t RES0_2:6;
            uint64_t AffinityValue:32;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_TYPER& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_TYPER & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_TYPER & setMandatoryFields()
    {
        PLPIS = 0;
        VLPIS = 0;
        RES0_0 = 0;
        DirectLPI = 0;
        Last = 0;
        DPGR = 0;
        RES0_1 = 0;
        ProcessorNumber = 0;
        CommonLPIAff = 0;
        RES0_2 = 0;
        AffinityValue = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_TYPER copy()const volatile
    {
     RegGICR_TYPER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_TYPER copy()const
    {
     RegGICR_TYPER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_TYPER: ";
            kout
                << "PLPIS = " << PLPIS << ", "
                << "VLPIS = " << VLPIS << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "DirectLPI = " << DirectLPI << ", "
                << "Last = " << Last << ", "
                << "DPGR = " << DPGR << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "ProcessorNumber = " << ProcessorNumber << ", "
                << "CommonLPIAff = " << CommonLPIAff << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "AffinityValue = " << AffinityValue << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_TYPER*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_TYPER make(uint64_t val)
    {
        RegGICR_TYPER res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_TYPER read(void* addr)
    {
        return *reinterpret_cast<RegGICR_TYPER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_TYPER& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_TYPER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_TYPER& update(volatile void* addr)
    {
        *reinterpret_cast<uint64_t*>(this)=*reinterpret_cast<volatile uint64_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_TYPER read(volatile void* addr)
    {
     uint64_t res=*reinterpret_cast<volatile uint64_t*>(addr);
        return *reinterpret_cast<RegGICR_TYPER*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_TYPER*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint64_t*>(addr)=*reinterpret_cast<const uint64_t*>(this);
    }
}__attribute__((packed));


class RegGICR_WAKER
{
public:
    using ScaleType=uint32_t;
            uint32_t IMP_DEF_0:1;
            uint32_t ProcessorSleep:1;
            uint32_t ChildrenAsleep:1;
            uint32_t RES0_0:28;
            uint32_t IMP_DEF_1:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICR_WAKER& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICR_WAKER & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICR_WAKER & setMandatoryFields()
    {
        IMP_DEF_0 = 0;
        ProcessorSleep = 0;
        ChildrenAsleep = 0;
        RES0_0 = 0;
        IMP_DEF_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICR_WAKER copy()const volatile
    {
     RegGICR_WAKER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICR_WAKER copy()const
    {
     RegGICR_WAKER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICR_WAKER: ";
            kout
                << "IMP_DEF_0 = " << IMP_DEF_0 << ", "
                << "ProcessorSleep = " << ProcessorSleep << ", "
                << "ChildrenAsleep = " << ChildrenAsleep << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "IMP_DEF_1 = " << IMP_DEF_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICR_WAKER*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICR_WAKER make(uint32_t val)
    {
        RegGICR_WAKER res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICR_WAKER read(void* addr)
    {
        return *reinterpret_cast<RegGICR_WAKER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_WAKER& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICR_WAKER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICR_WAKER& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICR_WAKER read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICR_WAKER*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICR_WAKER*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_CTLR
{
public:
    using ScaleType=uint32_t;
            uint32_t EnableGrp0:1;
            uint32_t EnableGrp1NS:1;
            uint32_t EnableGrp1S:1;
            uint32_t RES0_0:1;
            uint32_t ARE_S:1;
            uint32_t ARE_NS:1;
            uint32_t DS:1;
            uint32_t E1NWF:1;
            uint32_t RES0_1:23;
            uint32_t RWP:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_CTLR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_CTLR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_CTLR & setMandatoryFields()
    {
        EnableGrp0 = 0;
        EnableGrp1NS = 0;
        EnableGrp1S = 0;
        RES0_0 = 0;
        ARE_S = 0;
        ARE_NS = 0;
        DS = 0;
        E1NWF = 0;
        RES0_1 = 0;
        RWP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_CTLR copy()const volatile
    {
     RegGICD_CTLR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_CTLR copy()const
    {
     RegGICD_CTLR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_CTLR: ";
            kout
                << "EnableGrp0 = " << EnableGrp0 << ", "
                << "EnableGrp1NS = " << EnableGrp1NS << ", "
                << "EnableGrp1S = " << EnableGrp1S << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "ARE_S = " << ARE_S << ", "
                << "ARE_NS = " << ARE_NS << ", "
                << "DS = " << DS << ", "
                << "E1NWF = " << E1NWF << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "RWP = " << RWP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_CTLR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_CTLR make(uint32_t val)
    {
        RegGICD_CTLR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_CTLR read(void* addr)
    {
        return *reinterpret_cast<RegGICD_CTLR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_CTLR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_CTLR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_CTLR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_CTLR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_CTLR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_CTLR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_ICACTIVER
{
public:
    using ScaleType=uint32_t;
            uint32_t Actives:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_ICACTIVER& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_ICACTIVER & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_ICACTIVER & setMandatoryFields()
    {
        Actives = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_ICACTIVER copy()const volatile
    {
     RegGICD_ICACTIVER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_ICACTIVER copy()const
    {
     RegGICD_ICACTIVER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_ICACTIVER: ";
            kout
                << "Actives = " << Hex(Actives) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_ICACTIVER*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_ICACTIVER make(uint32_t val)
    {
        RegGICD_ICACTIVER res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_ICACTIVER read(void* addr)
    {
        return *reinterpret_cast<RegGICD_ICACTIVER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ICACTIVER& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_ICACTIVER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ICACTIVER& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_ICACTIVER read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_ICACTIVER*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_ICACTIVER*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_ICENABLER
{
public:
    using ScaleType=uint32_t;
            uint32_t ClearEnables:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_ICENABLER& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_ICENABLER & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_ICENABLER & setMandatoryFields()
    {
        ClearEnables = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_ICENABLER copy()const volatile
    {
     RegGICD_ICENABLER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_ICENABLER copy()const
    {
     RegGICD_ICENABLER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_ICENABLER: ";
            kout
                << "ClearEnables = " << Hex(ClearEnables) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_ICENABLER*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_ICENABLER make(uint32_t val)
    {
        RegGICD_ICENABLER res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_ICENABLER read(void* addr)
    {
        return *reinterpret_cast<RegGICD_ICENABLER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ICENABLER& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_ICENABLER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ICENABLER& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_ICENABLER read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_ICENABLER*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_ICENABLER*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_ICFGR
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:1;
            uint32_t cfg0:1;
            uint32_t RES0_1:1;
            uint32_t cfg1:1;
            uint32_t RES0_2:1;
            uint32_t cfg2:1;
            uint32_t RES0_3:1;
            uint32_t cfg3:1;
            uint32_t RES0_4:1;
            uint32_t cfg4:1;
            uint32_t RES0_5:1;
            uint32_t cfg5:1;
            uint32_t RES0_6:1;
            uint32_t cfg6:1;
            uint32_t RES0_7:1;
            uint32_t cfg7:1;
            uint32_t RES0_8:1;
            uint32_t cfg8:1;
            uint32_t RES0_9:1;
            uint32_t cfg9:1;
            uint32_t RES0_10:1;
            uint32_t cfg10:1;
            uint32_t RES0_11:1;
            uint32_t cfg11:1;
            uint32_t RES0_12:1;
            uint32_t cfg12:1;
            uint32_t RES0_13:1;
            uint32_t cfg13:1;
            uint32_t RES0_14:1;
            uint32_t cfg14:1;
            uint32_t RES0_15:1;
            uint32_t cfg15:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_ICFGR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_ICFGR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_ICFGR & setMandatoryFields()
    {
        RES0_0 = 0;
        cfg0 = 0;
        RES0_1 = 0;
        cfg1 = 0;
        RES0_2 = 0;
        cfg2 = 0;
        RES0_3 = 0;
        cfg3 = 0;
        RES0_4 = 0;
        cfg4 = 0;
        RES0_5 = 0;
        cfg5 = 0;
        RES0_6 = 0;
        cfg6 = 0;
        RES0_7 = 0;
        cfg7 = 0;
        RES0_8 = 0;
        cfg8 = 0;
        RES0_9 = 0;
        cfg9 = 0;
        RES0_10 = 0;
        cfg10 = 0;
        RES0_11 = 0;
        cfg11 = 0;
        RES0_12 = 0;
        cfg12 = 0;
        RES0_13 = 0;
        cfg13 = 0;
        RES0_14 = 0;
        cfg14 = 0;
        RES0_15 = 0;
        cfg15 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_ICFGR copy()const volatile
    {
     RegGICD_ICFGR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_ICFGR copy()const
    {
     RegGICD_ICFGR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_ICFGR: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "cfg0 = " << cfg0 << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "cfg1 = " << cfg1 << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "cfg2 = " << cfg2 << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "cfg3 = " << cfg3 << ", "
                << "RES0_4 = " << RES0_4 << ", "
                << "cfg4 = " << cfg4 << ", "
                << "RES0_5 = " << RES0_5 << ", "
                << "cfg5 = " << cfg5 << ", "
                << "RES0_6 = " << RES0_6 << ", "
                << "cfg6 = " << cfg6 << ", "
                << "RES0_7 = " << RES0_7 << ", "
                << "cfg7 = " << cfg7 << ", "
                << "RES0_8 = " << RES0_8 << ", "
                << "cfg8 = " << cfg8 << ", "
                << "RES0_9 = " << RES0_9 << ", "
                << "cfg9 = " << cfg9 << ", "
                << "RES0_10 = " << RES0_10 << ", "
                << "cfg10 = " << cfg10 << ", "
                << "RES0_11 = " << RES0_11 << ", "
                << "cfg11 = " << cfg11 << ", "
                << "RES0_12 = " << RES0_12 << ", "
                << "cfg12 = " << cfg12 << ", "
                << "RES0_13 = " << RES0_13 << ", "
                << "cfg13 = " << cfg13 << ", "
                << "RES0_14 = " << RES0_14 << ", "
                << "cfg14 = " << cfg14 << ", "
                << "RES0_15 = " << RES0_15 << ", "
                << "cfg15 = " << cfg15 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_ICFGR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_ICFGR make(uint32_t val)
    {
        RegGICD_ICFGR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_ICFGR read(void* addr)
    {
        return *reinterpret_cast<RegGICD_ICFGR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ICFGR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_ICFGR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ICFGR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_ICFGR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_ICFGR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_ICFGR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_ICPENDR
{
public:
    using ScaleType=uint32_t;
            uint32_t Clears:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_ICPENDR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_ICPENDR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_ICPENDR & setMandatoryFields()
    {
        Clears = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_ICPENDR copy()const volatile
    {
     RegGICD_ICPENDR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_ICPENDR copy()const
    {
     RegGICD_ICPENDR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_ICPENDR: ";
            kout
                << "Clears = " << Clears << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_ICPENDR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_ICPENDR make(uint32_t val)
    {
        RegGICD_ICPENDR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_ICPENDR read(void* addr)
    {
        return *reinterpret_cast<RegGICD_ICPENDR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ICPENDR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_ICPENDR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ICPENDR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_ICPENDR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_ICPENDR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_ICPENDR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_IGROUPR
{
public:
    using ScaleType=uint32_t;
            uint32_t InGrp:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_IGROUPR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_IGROUPR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_IGROUPR & setMandatoryFields()
    {
        InGrp = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_IGROUPR copy()const volatile
    {
     RegGICD_IGROUPR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_IGROUPR copy()const
    {
     RegGICD_IGROUPR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_IGROUPR: ";
            kout
                << "InGrp = " << InGrp << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_IGROUPR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_IGROUPR make(uint32_t val)
    {
        RegGICD_IGROUPR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_IGROUPR read(void* addr)
    {
        return *reinterpret_cast<RegGICD_IGROUPR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_IGROUPR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_IGROUPR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_IGROUPR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_IGROUPR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_IGROUPR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_IGROUPR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_IIDR
{
public:
    using ScaleType=uint32_t;
            uint32_t Implementer:12;
            uint32_t Revision:4;
            uint32_t Variant:4;
            uint32_t RES0_0:4;
            uint32_t ProductID:8;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_IIDR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_IIDR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_IIDR & setMandatoryFields()
    {
        Implementer = 0;
        Revision = 0;
        Variant = 0;
        RES0_0 = 0;
        ProductID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_IIDR copy()const volatile
    {
     RegGICD_IIDR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_IIDR copy()const
    {
     RegGICD_IIDR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_IIDR: ";
            kout
                << "Implementer = " << Implementer << ", "
                << "Revision = " << Revision << ", "
                << "Variant = " << Variant << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "ProductID = " << ProductID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_IIDR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_IIDR make(uint32_t val)
    {
        RegGICD_IIDR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_IIDR read(void* addr)
    {
        return *reinterpret_cast<RegGICD_IIDR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_IIDR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_IIDR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_IIDR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_IIDR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_IIDR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_IIDR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_IPRIORITYR
{
public:
    using ScaleType=uint32_t;
            uint32_t p0:8;
            uint32_t p1:8;
            uint32_t p2:8;
            uint32_t p3:8;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_IPRIORITYR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_IPRIORITYR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_IPRIORITYR & setMandatoryFields()
    {
        p0 = 0;
        p1 = 0;
        p2 = 0;
        p3 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_IPRIORITYR copy()const volatile
    {
     RegGICD_IPRIORITYR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_IPRIORITYR copy()const
    {
     RegGICD_IPRIORITYR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_IPRIORITYR: ";
            kout
                << "p0 = " << p0 << ", "
                << "p1 = " << p1 << ", "
                << "p2 = " << p2 << ", "
                << "p3 = " << p3 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_IPRIORITYR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_IPRIORITYR make(uint32_t val)
    {
        RegGICD_IPRIORITYR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_IPRIORITYR read(void* addr)
    {
        return *reinterpret_cast<RegGICD_IPRIORITYR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_IPRIORITYR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_IPRIORITYR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_IPRIORITYR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_IPRIORITYR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_IPRIORITYR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_IPRIORITYR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_ISACTIVER
{
public:
    using ScaleType=uint32_t;
            uint32_t Actives:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_ISACTIVER& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_ISACTIVER & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_ISACTIVER & setMandatoryFields()
    {
        Actives = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_ISACTIVER copy()const volatile
    {
     RegGICD_ISACTIVER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_ISACTIVER copy()const
    {
     RegGICD_ISACTIVER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_ISACTIVER: ";
            kout
                << "Actives = " << Hex(Actives) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_ISACTIVER*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_ISACTIVER make(uint32_t val)
    {
        RegGICD_ISACTIVER res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_ISACTIVER read(void* addr)
    {
        return *reinterpret_cast<RegGICD_ISACTIVER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ISACTIVER& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_ISACTIVER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ISACTIVER& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_ISACTIVER read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_ISACTIVER*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_ISACTIVER*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_ISENABLER
{
public:
    using ScaleType=uint32_t;
            uint32_t Enables:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_ISENABLER& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_ISENABLER & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_ISENABLER & setMandatoryFields()
    {
        Enables = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_ISENABLER copy()const volatile
    {
     RegGICD_ISENABLER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_ISENABLER copy()const
    {
     RegGICD_ISENABLER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_ISENABLER: ";
            kout
                << "Enables = " << Hex(Enables) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_ISENABLER*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_ISENABLER make(uint32_t val)
    {
        RegGICD_ISENABLER res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_ISENABLER read(void* addr)
    {
        return *reinterpret_cast<RegGICD_ISENABLER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ISENABLER& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_ISENABLER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ISENABLER& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_ISENABLER read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_ISENABLER*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_ISENABLER*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_ISPENDR
{
public:
    using ScaleType=uint32_t;
            uint32_t Pendings:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_ISPENDR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_ISPENDR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_ISPENDR & setMandatoryFields()
    {
        Pendings = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_ISPENDR copy()const volatile
    {
     RegGICD_ISPENDR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_ISPENDR copy()const
    {
     RegGICD_ISPENDR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_ISPENDR: ";
            kout
                << "Pendings = " << Hex(Pendings) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_ISPENDR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_ISPENDR make(uint32_t val)
    {
        RegGICD_ISPENDR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_ISPENDR read(void* addr)
    {
        return *reinterpret_cast<RegGICD_ISPENDR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ISPENDR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_ISPENDR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_ISPENDR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_ISPENDR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_ISPENDR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_ISPENDR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_SGIR
{
public:
    using ScaleType=uint32_t;
            uint32_t INTID:4;
            uint32_t RES0_0:11;
            uint32_t NSTATT:1;
            uint32_t CPUTargetList:8;
            uint32_t TargetListFilter:2;
            uint32_t RES0_1:6;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_SGIR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_SGIR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_SGIR & setMandatoryFields()
    {
        INTID = 0;
        RES0_0 = 0;
        NSTATT = 0;
        CPUTargetList = 0;
        TargetListFilter = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_SGIR copy()const volatile
    {
     RegGICD_SGIR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_SGIR copy()const
    {
     RegGICD_SGIR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_SGIR: ";
            kout
                << "INTID = " << INTID << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "NSTATT = " << NSTATT << ", "
                << "CPUTargetList = " << CPUTargetList << ", "
                << "TargetListFilter = " << TargetListFilter << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_SGIR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_SGIR make(uint32_t val)
    {
        RegGICD_SGIR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_SGIR read(void* addr)
    {
        return *reinterpret_cast<RegGICD_SGIR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_SGIR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_SGIR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_SGIR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_SGIR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_SGIR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_SGIR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_SPENDSGIR
{
public:
    using ScaleType=uint32_t;
            uint32_t set0:8;
            uint32_t set1:8;
            uint32_t set2:8;
            uint32_t set3:8;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_SPENDSGIR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_SPENDSGIR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_SPENDSGIR & setMandatoryFields()
    {
        set0 = 0;
        set1 = 0;
        set2 = 0;
        set3 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_SPENDSGIR copy()const volatile
    {
     RegGICD_SPENDSGIR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_SPENDSGIR copy()const
    {
     RegGICD_SPENDSGIR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_SPENDSGIR: ";
            kout
                << "set0 = " << set0 << ", "
                << "set1 = " << set1 << ", "
                << "set2 = " << set2 << ", "
                << "set3 = " << set3 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_SPENDSGIR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_SPENDSGIR make(uint32_t val)
    {
        RegGICD_SPENDSGIR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_SPENDSGIR read(void* addr)
    {
        return *reinterpret_cast<RegGICD_SPENDSGIR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_SPENDSGIR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_SPENDSGIR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_SPENDSGIR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_SPENDSGIR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_SPENDSGIR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_SPENDSGIR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_STATUSR
{
public:
    using ScaleType=uint32_t;
            uint32_t RRD:1;
            uint32_t WRD:1;
            uint32_t RWOD:1;
            uint32_t WROD:1;
            uint32_t RES0_0:28;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_STATUSR& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_STATUSR & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_STATUSR & setMandatoryFields()
    {
        RRD = 0;
        WRD = 0;
        RWOD = 0;
        WROD = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_STATUSR copy()const volatile
    {
     RegGICD_STATUSR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_STATUSR copy()const
    {
     RegGICD_STATUSR res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_STATUSR: ";
            kout
                << "RRD = " << RRD << ", "
                << "WRD = " << WRD << ", "
                << "RWOD = " << RWOD << ", "
                << "WROD = " << WROD << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_STATUSR*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_STATUSR make(uint32_t val)
    {
        RegGICD_STATUSR res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_STATUSR read(void* addr)
    {
        return *reinterpret_cast<RegGICD_STATUSR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_STATUSR& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_STATUSR*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_STATUSR& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_STATUSR read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_STATUSR*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_STATUSR*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));


class RegGICD_TYPER
{
public:
    using ScaleType=uint32_t;
            uint32_t ITLinesNumber:5;
            uint32_t CPUNumber:3;
            uint32_t RES0_0:2;
            uint32_t SecurityExtn:1;
            uint32_t RES0_1:5;
            uint32_t MBIS:1;
            uint32_t LPIS:1;
            uint32_t DVIS:1;
            uint32_t IDbits:5;
            uint32_t A3V:1;
            uint32_t No1N:1;
            uint32_t RSS:1;
            uint32_t RES0_2:5;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegGICD_TYPER& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegGICD_TYPER & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegGICD_TYPER & setMandatoryFields()
    {
        ITLinesNumber = 0;
        CPUNumber = 0;
        RES0_0 = 0;
        SecurityExtn = 0;
        RES0_1 = 0;
        MBIS = 0;
        LPIS = 0;
        DVIS = 0;
        IDbits = 0;
        A3V = 0;
        No1N = 0;
        RSS = 0;
        RES0_2 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegGICD_TYPER copy()const volatile
    {
     RegGICD_TYPER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegGICD_TYPER copy()const
    {
     RegGICD_TYPER res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegGICD_TYPER: ";
            kout
                << "ITLinesNumber = " << ITLinesNumber << ", "
                << "CPUNumber = " << CPUNumber << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "SecurityExtn = " << SecurityExtn << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "MBIS = " << MBIS << ", "
                << "LPIS = " << LPIS << ", "
                << "DVIS = " << DVIS << ", "
                << "IDbits = " << IDbits << ", "
                << "A3V = " << A3V << ", "
                << "No1N = " << No1N << ", "
                << "RSS = " << RSS << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegGICD_TYPER*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegGICD_TYPER make(uint32_t val)
    {
        RegGICD_TYPER res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegGICD_TYPER read(void* addr)
    {
        return *reinterpret_cast<RegGICD_TYPER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_TYPER& update(void* addr)
    {
        return *this=*reinterpret_cast<RegGICD_TYPER*>(addr);
    }
    __attribute__((always_inline)) inline RegGICD_TYPER& update(volatile void* addr)
    {
        *reinterpret_cast<uint32_t*>(this)=*reinterpret_cast<volatile uint32_t*>(addr);
        return *this;
    }
    __attribute__((always_inline)) inline static RegGICD_TYPER read(volatile void* addr)
    {
     uint32_t res=*reinterpret_cast<volatile uint32_t*>(addr);
        return *reinterpret_cast<RegGICD_TYPER*>(&res);
    }
    __attribute__((always_inline)) inline void write(void *addr)const
    {
        *reinterpret_cast<RegGICD_TYPER*>(addr)=*this;
    }
    __attribute__((always_inline)) inline void write(volatile void *addr)const
    {
        *reinterpret_cast<volatile uint32_t*>(addr)=*reinterpret_cast<const uint32_t*>(this);
    }
}__attribute__((packed));
# 14 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICCPUInterface.h" 2
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 1 3
# 58 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3
       
# 59 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3
# 69 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 1 3
# 67 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3

# 67 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
 
# 85 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

 
  }

}
# 70 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 2 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 1 3
# 59 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 1 3
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/concept_check.h" 1 3
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/concept_check.h" 3
       
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/concept_check.h" 3
# 35 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }


}


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 1 3
# 32 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
       
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{

# 68 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }




      constexpr value_type operator()() const { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 103 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };
# 195 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 327 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 355 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 939 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;

  template<typename _Tp, typename... _Args>
    struct is_constructible;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>,
       __not_<is_constructible<__dst_t, _From>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1774 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<wchar_t> : __make_signed<unsigned int>
    { };



  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };
# 1893 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2039 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2078 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;


  template<typename...> using __void_t = void;
# 2507 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2551 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename remove_cv<
      typename remove_reference<_Tp>::type>::type>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };
# 2756 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Result, typename _Ret, typename = void>
    struct __is_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
    : is_convertible<typename _Result::type, _Ret>::type
    { };

  template<typename _Result>
    struct __is_invocable_impl<_Result, void, __void_t<typename _Result::type>>
    : true_type
    { };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 3112 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3

}
# 55 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 115 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 135 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
# 166 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 181 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };




  struct __nonesuch_no_braces : std::__nonesuch {
    explicit __nonesuch_no_braces(const __nonesuch&) = delete;
  };
# 197 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 241 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;

      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 269 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __not_<__and_<is_copy_assignable<_T1>,
                is_copy_assignable<_T2>>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p) = delete;

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch_no_braces&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
    is_assignable<_T2&, const _U2&>>::value,
    pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
    is_assignable<_T2&, _U2&&>>::value,
    pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };






  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline





    void

    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 516 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 535 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3

}
# 71 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 2 3





# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/initializer_list" 1 3
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/initializer_list" 3
       
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 77 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp, typename = void>
    struct __tuple_size_cv_impl { };

  template<typename _Tp>
    struct __tuple_size_cv_impl<_Tp, __void_t<decltype(tuple_size<_Tp>::value)>>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };



  template<typename _Tp>
    struct tuple_size<const _Tp> : __tuple_size_cv_impl<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp> : __tuple_size_cv_impl<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp> : __tuple_size_cv_impl<_Tp> { };
# 132 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3
  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };




  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes> struct _Index_tuple { };


  template<typename _Itup1, typename _Itup2> struct _Itup_cat;

  template<size_t... _Ind1, size_t... _Ind2>
    struct _Itup_cat<_Index_tuple<_Ind1...>, _Index_tuple<_Ind2...>>
    {
      using __type = _Index_tuple<_Ind1..., (_Ind2 + sizeof...(_Ind1))...>;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    : _Itup_cat<typename _Build_index_tuple<_Num / 2>::__type,
  typename _Build_index_tuple<_Num - _Num / 2>::__type>
    { };

  template<>
    struct _Build_index_tuple<1>
    {
      typedef _Index_tuple<0> __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num, size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
       "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;


  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 406 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3

}
# 15 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICCPUInterface.h" 2





# 19 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICCPUInterface.h"
class GICCPUInterface{
public:
 GICCPUInterface()=default;
 int init(uint8_t lowestPriority,bool a3vEn,EOIMode mode);


 __attribute__((always_inline)) inline uint8_t runningPriority()const{return 0;}


 void lowestAllowedPriority(uint8_t priorty);
 uint8_t lowestAllowedPrioirty()const;


 template <int grp>
 __attribute__((always_inline)) inline IntID ack();
 template <int grp>
 __attribute__((always_inline)) inline void eoi(IntID id);


 template <int grp>
 void subPriorityBits(size_t n);


 __attribute__((always_inline)) inline size_t IDBits()const
 {
  return _ctrl.IDbits==0?16:24;
 }

 __attribute__((always_inline)) inline size_t PRIBits()const
 {
  return _ctrl.PRIbits;
 }


 template <int grp>
 void enableGroup(bool enable);
 void enableSystemRegister();

 template <int grp>
 void sgiTarget(IntID id,uint8_t aff3,uint8_t aff2,uint8_t aff1,uint8_t aff0);
 template <int grp>
 void sgiSelf(IntID id);
 template <int grp>
 void sgiTargetList(IntID id,uint8_t aff3,uint8_t aff2,uint8_t aff1,uint16_t aff0Bits);
 template <int grp>
 void sgiAllOtherCPUs(IntID id);

private:
 RegICC_CTLR_EL1 _ctrl;


};

# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/interrupt/GICCPUInterface.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/interrupt/GICCPUInterface.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICCPUInterface.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/interrupt/GICCPUInterface.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/system_common_registers.h" 1
# 10 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/system_common_registers.h"
class RegCurrentEL
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:2;
            uint32_t EL:2;
            uint32_t RES0_1:28;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegCurrentEL& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegCurrentEL & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegCurrentEL & setMandatoryFields()
    {
        RES0_0 = 0;
        EL = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegCurrentEL copy()const volatile
    {
     RegCurrentEL res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegCurrentEL copy()const
    {
     RegCurrentEL res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegCurrentEL: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegCurrentEL*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegCurrentEL make(uint32_t val)
    {
        RegCurrentEL res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegCurrentEL read()
    {
        RegCurrentEL res;
        __asm__ __volatile__("mrs %0,CurrentEL\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegCurrentEL & update()
    {
        __asm__ __volatile__("mrs %0,CurrentEL\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr CurrentEL,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDAIF
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:6;
            uint32_t F:1;
            uint32_t I:1;
            uint32_t A:1;
            uint32_t D:1;
            uint32_t RES0_1:22;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegDAIF& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegDAIF & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegDAIF & setMandatoryFields()
    {
        RES0_0 = 0;
        F = 0;
        I = 0;
        A = 0;
        D = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegDAIF copy()const volatile
    {
     RegDAIF res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegDAIF copy()const
    {
     RegDAIF res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegDAIF: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "F = " << F << ", "
                << "I = " << I << ", "
                << "A = " << A << ", "
                << "D = " << D << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegDAIF*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegDAIF make(uint32_t val)
    {
        RegDAIF res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegDAIF read()
    {
        RegDAIF res;
        __asm__ __volatile__("mrs %0,DAIF\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegDAIF & update()
    {
        __asm__ __volatile__("mrs %0,DAIF\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr DAIF,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegVBAR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t Addr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegVBAR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegVBAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegVBAR_EL1 & setMandatoryFields()
    {
        Addr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegVBAR_EL1 copy()const volatile
    {
     RegVBAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegVBAR_EL1 copy()const
    {
     RegVBAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegVBAR_EL1: ";
            kout
                << "Addr = " << Hex(Addr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegVBAR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegVBAR_EL1 make(uint64_t val)
    {
        RegVBAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegVBAR_EL1 read()
    {
        RegVBAR_EL1 res;
        __asm__ __volatile__("mrs %0,VBAR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegVBAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,VBAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr VBAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t returnAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegELR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegELR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegELR_EL1 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegELR_EL1 copy()const volatile
    {
     RegELR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegELR_EL1 copy()const
    {
     RegELR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegELR_EL1: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegELR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegELR_EL1 make(uint64_t val)
    {
        RegELR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegELR_EL1 read()
    {
        RegELR_EL1 res;
        __asm__ __volatile__("mrs %0,ELR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegELR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ELR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t returnAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegELR_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegELR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegELR_EL2 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegELR_EL2 copy()const volatile
    {
     RegELR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegELR_EL2 copy()const
    {
     RegELR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegELR_EL2: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegELR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegELR_EL2 make(uint64_t val)
    {
        RegELR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegELR_EL2 read()
    {
        RegELR_EL2 res;
        __asm__ __volatile__("mrs %0,ELR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegELR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ELR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t returnAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegELR_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegELR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegELR_EL3 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegELR_EL3 copy()const volatile
    {
     RegELR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegELR_EL3 copy()const
    {
     RegELR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegELR_EL3: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegELR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegELR_EL3 make(uint64_t val)
    {
        RegELR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegELR_EL3 read()
    {
        RegELR_EL3 res;
        __asm__ __volatile__("mrs %0,ELR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegELR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ELR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t ISS:25;
            uint32_t IL:1;
            uint32_t EC:6;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegESR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegESR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegESR_EL1 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegESR_EL1 copy()const volatile
    {
     RegESR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegESR_EL1 copy()const
    {
     RegESR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegESR_EL1: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegESR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegESR_EL1 make(uint32_t val)
    {
        RegESR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegESR_EL1 read()
    {
        RegESR_EL1 res;
        __asm__ __volatile__("mrs %0,ESR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegESR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ESR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL2
{
public:
    using ScaleType=uint32_t;
            uint32_t ISS:25;
            uint32_t IL:1;
            uint32_t EC:6;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegESR_EL2& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegESR_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegESR_EL2 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegESR_EL2 copy()const volatile
    {
     RegESR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegESR_EL2 copy()const
    {
     RegESR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegESR_EL2: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegESR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegESR_EL2 make(uint32_t val)
    {
        RegESR_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegESR_EL2 read()
    {
        RegESR_EL2 res;
        __asm__ __volatile__("mrs %0,ESR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegESR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ESR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL3
{
public:
    using ScaleType=uint32_t;
            uint32_t ISS:25;
            uint32_t IL:1;
            uint32_t EC:6;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegESR_EL3& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegESR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegESR_EL3 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegESR_EL3 copy()const volatile
    {
     RegESR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegESR_EL3 copy()const
    {
     RegESR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegESR_EL3: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegESR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegESR_EL3 make(uint32_t val)
    {
        RegESR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegESR_EL3 read()
    {
        RegESR_EL3 res;
        __asm__ __volatile__("mrs %0,ESR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegESR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ESR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t faultAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegFAR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegFAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegFAR_EL1 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegFAR_EL1 copy()const volatile
    {
     RegFAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL1 copy()const
    {
     RegFAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegFAR_EL1: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegFAR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegFAR_EL1 make(uint64_t val)
    {
        RegFAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegFAR_EL1 read()
    {
        RegFAR_EL1 res;
        __asm__ __volatile__("mrs %0,FAR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr FAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t faultAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegFAR_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegFAR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegFAR_EL2 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegFAR_EL2 copy()const volatile
    {
     RegFAR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL2 copy()const
    {
     RegFAR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegFAR_EL2: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegFAR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegFAR_EL2 make(uint64_t val)
    {
        RegFAR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegFAR_EL2 read()
    {
        RegFAR_EL2 res;
        __asm__ __volatile__("mrs %0,FAR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr FAR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t faultAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegFAR_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegFAR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegFAR_EL3 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegFAR_EL3 copy()const volatile
    {
     RegFAR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL3 copy()const
    {
     RegFAR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegFAR_EL3: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegFAR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegFAR_EL3 make(uint64_t val)
    {
        RegFAR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegFAR_EL3 read()
    {
        RegFAR_EL3 res;
        __asm__ __volatile__("mrs %0,FAR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr FAR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSR_EL1 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSR_EL1 copy()const volatile
    {
     RegSPSR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL1 copy()const
    {
     RegSPSR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSR_EL1: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSR_EL1 make(uint32_t val)
    {
        RegSPSR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSR_EL1 read()
    {
        RegSPSR_EL1 res;
        __asm__ __volatile__("mrs %0,SPSR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL2
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSR_EL2& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSR_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSR_EL2 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSR_EL2 copy()const volatile
    {
     RegSPSR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL2 copy()const
    {
     RegSPSR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSR_EL2: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSR_EL2 make(uint32_t val)
    {
        RegSPSR_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSR_EL2 read()
    {
        RegSPSR_EL2 res;
        __asm__ __volatile__("mrs %0,SPSR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL3
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSR_EL3& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSR_EL3 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSR_EL3 copy()const volatile
    {
     RegSPSR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL3 copy()const
    {
     RegSPSR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSR_EL3: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSR_EL3 make(uint32_t val)
    {
        RegSPSR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSR_EL3 read()
    {
        RegSPSR_EL3 res;
        __asm__ __volatile__("mrs %0,SPSR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP copy()const volatile
    {
     RegSP res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP copy()const
    {
     RegSP res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP make(uint64_t val)
    {
        RegSP res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP read()
    {
        RegSP res;
        __asm__ __volatile__("mrs %0,SP\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP & update()
    {
        __asm__ __volatile__("mrs %0,SP\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL0
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL0& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL0 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL0 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL0 copy()const volatile
    {
     RegSP_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL0 copy()const
    {
     RegSP_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL0: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL0 make(uint64_t val)
    {
        RegSP_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL0 read()
    {
        RegSP_EL0 res;
        __asm__ __volatile__("mrs %0,SP_EL0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL0\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL1 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL1 copy()const volatile
    {
     RegSP_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL1 copy()const
    {
     RegSP_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL1: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL1 make(uint64_t val)
    {
        RegSP_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL1 read()
    {
        RegSP_EL1 res;
        __asm__ __volatile__("mrs %0,SP_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL2 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL2 copy()const volatile
    {
     RegSP_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL2 copy()const
    {
     RegSP_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL2: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL2 make(uint64_t val)
    {
        RegSP_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL2 read()
    {
        RegSP_EL2 res;
        __asm__ __volatile__("mrs %0,SP_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL3 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL3 copy()const volatile
    {
     RegSP_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL3 copy()const
    {
     RegSP_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL3: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL3 make(uint64_t val)
    {
        RegSP_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL3 read()
    {
        RegSP_EL3 res;
        __asm__ __volatile__("mrs %0,SP_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegNZCV
{
public:
    using ScaleType=uint64_t;
            uint64_t RES0_0:28;
            uint64_t V:1;
            uint64_t C:1;
            uint64_t Z:1;
            uint64_t N:1;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegNZCV& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegNZCV & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegNZCV & setMandatoryFields()
    {
        RES0_0 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegNZCV copy()const volatile
    {
     RegNZCV res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegNZCV copy()const
    {
     RegNZCV res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegNZCV: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegNZCV*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegNZCV make(uint64_t val)
    {
        RegNZCV res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegNZCV read()
    {
        RegNZCV res;
        __asm__ __volatile__("mrs %0,NZCV\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegNZCV & update()
    {
        __asm__ __volatile__("mrs %0,NZCV\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr NZCV,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPAN
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:22;
            uint32_t PAN:1;
            uint32_t RES0_1:9;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegPAN& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegPAN & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegPAN & setMandatoryFields()
    {
        RES0_0 = 0;
        PAN = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegPAN copy()const volatile
    {
     RegPAN res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegPAN copy()const
    {
     RegPAN res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegPAN: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "PAN = " << PAN << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegPAN*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegPAN make(uint32_t val)
    {
        RegPAN res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegPAN read()
    {
        RegPAN res;
        __asm__ __volatile__("mrs %0,PAN\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegPAN & update()
    {
        __asm__ __volatile__("mrs %0,PAN\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr PAN,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSel
{
public:
    using ScaleType=uint32_t;
            uint32_t SP:1;
            uint32_t RES0_0:31;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSel& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSel & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSel & setMandatoryFields()
    {
        SP = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSel copy()const volatile
    {
     RegSPSel res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSel copy()const
    {
     RegSPSel res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSel: ";
            kout
                << "SP = " << SP << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSel*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSel make(uint32_t val)
    {
        RegSPSel res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSel read()
    {
        RegSPSel res;
        __asm__ __volatile__("mrs %0,SPSel\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSel & update()
    {
        __asm__ __volatile__("mrs %0,SPSel\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSel,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegUAO
{
public:
    using ScaleType=uint64_t;
            uint64_t RES0_0:23;
            uint64_t UAO:1;
            uint64_t RES0_1:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegUAO& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegUAO & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegUAO & setMandatoryFields()
    {
        RES0_0 = 0;
        UAO = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegUAO copy()const volatile
    {
     RegUAO res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegUAO copy()const
    {
     RegUAO res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegUAO: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "UAO = " << UAO << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegUAO*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegUAO make(uint64_t val)
    {
        RegUAO res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegUAO read()
    {
        RegUAO res;
        __asm__ __volatile__("mrs %0,UAO\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegUAO & update()
    {
        __asm__ __volatile__("mrs %0,UAO\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr UAO,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPC
{
public:
    using ScaleType=uint64_t;
            uint64_t PC:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegPC& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegPC & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegPC & setMandatoryFields()
    {
        PC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegPC copy()const volatile
    {
     RegPC res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegPC copy()const
    {
     RegPC res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegPC: ";
            kout
                << "PC = " << Hex(PC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegPC*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegPC make(uint64_t val)
    {
        RegPC res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegPC read()
    {
        RegPC res;
        __asm__ __volatile__("mrs %0,PC\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegPC & update()
    {
        __asm__ __volatile__("mrs %0,PC\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr PC,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTCR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t T0SZ:6;
            uint64_t RES0_0:1;
            uint64_t EPD0:1;
            uint64_t IRGN0:2;
            uint64_t ORGN0:2;
            uint64_t SH0:2;
            uint64_t TG0:2;
            uint64_t T1SZ:6;
            uint64_t A1:1;
            uint64_t EPD1:1;
            uint64_t IRGN1:2;
            uint64_t ORGN1:2;
            uint64_t SH1:2;
            uint64_t TG1:2;
            uint64_t IPS:3;
            uint64_t RES0_1:1;
            uint64_t AS:1;
            uint64_t TBI0:1;
            uint64_t TBI1:1;
            uint64_t HA:1;
            uint64_t HD:1;
            uint64_t HPD0:1;
            uint64_t HPD1:1;
            uint64_t HWU059:1;
            uint64_t HWU060:1;
            uint64_t HWU061:1;
            uint64_t HWU062:1;
            uint64_t HWU159:1;
            uint64_t HWU160:1;
            uint64_t HWU161:1;
            uint64_t HWU162:1;
            uint64_t RES0_2:2;
            uint64_t NFD0:1;
            uint64_t NFD1:1;
            uint64_t RES0_3:9;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegTCR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegTCR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegTCR_EL1 & setMandatoryFields()
    {
        T0SZ = 0;
        RES0_0 = 0;
        EPD0 = 0;
        IRGN0 = 0;
        ORGN0 = 0;
        SH0 = 0;
        TG0 = 0;
        T1SZ = 0;
        A1 = 0;
        EPD1 = 0;
        IRGN1 = 0;
        ORGN1 = 0;
        SH1 = 0;
        TG1 = 0;
        IPS = 0;
        RES0_1 = 0;
        AS = 0;
        TBI0 = 0;
        TBI1 = 0;
        HA = 0;
        HD = 0;
        HPD0 = 0;
        HPD1 = 0;
        HWU059 = 0;
        HWU060 = 0;
        HWU061 = 0;
        HWU062 = 0;
        HWU159 = 0;
        HWU160 = 0;
        HWU161 = 0;
        HWU162 = 0;
        RES0_2 = 0;
        NFD0 = 0;
        NFD1 = 0;
        RES0_3 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegTCR_EL1 copy()const volatile
    {
     RegTCR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegTCR_EL1 copy()const
    {
     RegTCR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegTCR_EL1: ";
            kout
                << "T0SZ = " << T0SZ << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EPD0 = " << EPD0 << ", "
                << "IRGN0 = " << IRGN0 << ", "
                << "ORGN0 = " << ORGN0 << ", "
                << "SH0 = " << SH0 << ", "
                << "TG0 = " << TG0 << ", "
                << "T1SZ = " << T1SZ << ", "
                << "A1 = " << A1 << ", "
                << "EPD1 = " << EPD1 << ", "
                << "IRGN1 = " << IRGN1 << ", "
                << "ORGN1 = " << ORGN1 << ", "
                << "SH1 = " << SH1 << ", "
                << "TG1 = " << TG1 << ", "
                << "IPS = " << IPS << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "AS = " << AS << ", "
                << "TBI0 = " << TBI0 << ", "
                << "TBI1 = " << TBI1 << ", "
                << "HA = " << HA << ", "
                << "HD = " << HD << ", "
                << "HPD0 = " << HPD0 << ", "
                << "HPD1 = " << HPD1 << ", "
                << "HWU059 = " << HWU059 << ", "
                << "HWU060 = " << HWU060 << ", "
                << "HWU061 = " << HWU061 << ", "
                << "HWU062 = " << HWU062 << ", "
                << "HWU159 = " << HWU159 << ", "
                << "HWU160 = " << HWU160 << ", "
                << "HWU161 = " << HWU161 << ", "
                << "HWU162 = " << HWU162 << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "NFD0 = " << NFD0 << ", "
                << "NFD1 = " << NFD1 << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegTCR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegTCR_EL1 make(uint64_t val)
    {
        RegTCR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegTCR_EL1 read()
    {
        RegTCR_EL1 res;
        __asm__ __volatile__("mrs %0,TCR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegTCR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TCR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr TCR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegISR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:6;
            uint32_t F:1;
            uint32_t I:1;
            uint32_t A:1;
            uint32_t RES0_1:23;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegISR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegISR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegISR_EL1 & setMandatoryFields()
    {
        RES0_0 = 0;
        F = 0;
        I = 0;
        A = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegISR_EL1 copy()const volatile
    {
     RegISR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegISR_EL1 copy()const
    {
     RegISR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegISR_EL1: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "F = " << F << ", "
                << "I = " << I << ", "
                << "A = " << A << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegISR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegISR_EL1 make(uint32_t val)
    {
        RegISR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegISR_EL1 read()
    {
        RegISR_EL1 res;
        __asm__ __volatile__("mrs %0,ISR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegISR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ISR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ISR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64ISAR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t RES0_0:4;
            uint64_t AES:4;
            uint64_t SHA1:4;
            uint64_t SHA2:4;
            uint64_t CRC32:4;
            uint64_t Atomic:4;
            uint64_t RES0_1:4;
            uint64_t RDM:4;
            uint64_t SHA3:4;
            uint64_t SM3:4;
            uint64_t SM4:4;
            uint64_t DP:4;
            uint64_t RES0_2:16;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64ISAR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 & setMandatoryFields()
    {
        RES0_0 = 0;
        AES = 0;
        SHA1 = 0;
        SHA2 = 0;
        CRC32 = 0;
        Atomic = 0;
        RES0_1 = 0;
        RDM = 0;
        SHA3 = 0;
        SM3 = 0;
        SM4 = 0;
        DP = 0;
        RES0_2 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 copy()const volatile
    {
     RegID_AA64ISAR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 copy()const
    {
     RegID_AA64ISAR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64ISAR0_EL1: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "AES = " << AES << ", "
                << "SHA1 = " << SHA1 << ", "
                << "SHA2 = " << SHA2 << ", "
                << "CRC32 = " << CRC32 << ", "
                << "Atomic = " << Atomic << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "RDM = " << RDM << ", "
                << "SHA3 = " << SHA3 << ", "
                << "SM3 = " << SM3 << ", "
                << "SM4 = " << SM4 << ", "
                << "DP = " << DP << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64ISAR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64ISAR0_EL1 make(uint64_t val)
    {
        RegID_AA64ISAR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64ISAR0_EL1 read()
    {
        RegID_AA64ISAR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64ISAR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64ISAR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64ISAR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegCONTEXTIDR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t PROCID:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegCONTEXTIDR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 & setMandatoryFields()
    {
        PROCID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 copy()const volatile
    {
     RegCONTEXTIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 copy()const
    {
     RegCONTEXTIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegCONTEXTIDR_EL1: ";
            kout
                << "PROCID = " << PROCID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegCONTEXTIDR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegCONTEXTIDR_EL1 make(uint32_t val)
    {
        RegCONTEXTIDR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegCONTEXTIDR_EL1 read()
    {
        RegCONTEXTIDR_EL1 res;
        __asm__ __volatile__("mrs %0,CONTEXTIDR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,CONTEXTIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr CONTEXTIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64PFR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t EL0:4;
            uint64_t EL1:4;
            uint64_t EL2:4;
            uint64_t EL3:4;
            uint64_t FP:4;
            uint64_t AdvSIMD:4;
            uint64_t GIC:4;
            uint64_t RAS:4;
            uint64_t SVE:4;
            uint64_t RES0_0:28;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64PFR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 & setMandatoryFields()
    {
        EL0 = 0;
        EL1 = 0;
        EL2 = 0;
        EL3 = 0;
        FP = 0;
        AdvSIMD = 0;
        GIC = 0;
        RAS = 0;
        SVE = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 copy()const volatile
    {
     RegID_AA64PFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 copy()const
    {
     RegID_AA64PFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64PFR0_EL1: ";
            kout
                << "EL0 = " << EL0 << ", "
                << "EL1 = " << EL1 << ", "
                << "EL2 = " << EL2 << ", "
                << "EL3 = " << EL3 << ", "
                << "FP = " << FP << ", "
                << "AdvSIMD = " << AdvSIMD << ", "
                << "GIC = " << GIC << ", "
                << "RAS = " << RAS << ", "
                << "SVE = " << SVE << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64PFR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64PFR0_EL1 make(uint64_t val)
    {
        RegID_AA64PFR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64PFR0_EL1 read()
    {
        RegID_AA64PFR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64PFR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64PFR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64PFR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64MMFR1_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t HAFDBS:4;
            uint64_t VMIDBits:4;
            uint64_t VH:4;
            uint64_t HPDS:4;
            uint64_t LO:4;
            uint64_t PAN:4;
            uint64_t SpecSEI:4;
            uint64_t XNX:4;
            uint64_t RES0_0:32;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64MMFR1_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 & setMandatoryFields()
    {
        HAFDBS = 0;
        VMIDBits = 0;
        VH = 0;
        HPDS = 0;
        LO = 0;
        PAN = 0;
        SpecSEI = 0;
        XNX = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 copy()const volatile
    {
     RegID_AA64MMFR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 copy()const
    {
     RegID_AA64MMFR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64MMFR1_EL1: ";
            kout
                << "HAFDBS = " << HAFDBS << ", "
                << "VMIDBits = " << VMIDBits << ", "
                << "VH = " << VH << ", "
                << "HPDS = " << HPDS << ", "
                << "LO = " << LO << ", "
                << "PAN = " << PAN << ", "
                << "SpecSEI = " << SpecSEI << ", "
                << "XNX = " << XNX << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64MMFR1_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR1_EL1 make(uint64_t val)
    {
        RegID_AA64MMFR1_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR1_EL1 read()
    {
        RegID_AA64MMFR1_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64MMFR1_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64MMFR1_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64MMFR1_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64MMFR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t PARange:4;
            uint64_t ASIDBits:4;
            uint64_t BigEnd:4;
            uint64_t SNSMem:4;
            uint64_t BigEndEL0:4;
            uint64_t TGran16:4;
            uint64_t TGran64:4;
            uint64_t TGran4:4;
            uint64_t RES0_0:32;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64MMFR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 & setMandatoryFields()
    {
        PARange = 0;
        ASIDBits = 0;
        BigEnd = 0;
        SNSMem = 0;
        BigEndEL0 = 0;
        TGran16 = 0;
        TGran64 = 0;
        TGran4 = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 copy()const volatile
    {
     RegID_AA64MMFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 copy()const
    {
     RegID_AA64MMFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64MMFR0_EL1: ";
            kout
                << "PARange = " << PARange << ", "
                << "ASIDBits = " << ASIDBits << ", "
                << "BigEnd = " << BigEnd << ", "
                << "SNSMem = " << SNSMem << ", "
                << "BigEndEL0 = " << BigEndEL0 << ", "
                << "TGran16 = " << Hex(TGran16) << ", "
                << "TGran64 = " << Hex(TGran64) << ", "
                << "TGran4 = " << Hex(TGran4) << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64MMFR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR0_EL1 make(uint64_t val)
    {
        RegID_AA64MMFR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR0_EL1 read()
    {
        RegID_AA64MMFR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64MMFR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64MMFR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64MMFR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMIDR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t Revision:4;
            uint32_t PartNum:12;
            uint32_t Architecture:4;
            uint32_t Variant:4;
            uint32_t Implementer:8;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegMIDR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMIDR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMIDR_EL1 & setMandatoryFields()
    {
        Revision = 0;
        PartNum = 0;
        Architecture = 0;
        Variant = 0;
        Implementer = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMIDR_EL1 copy()const volatile
    {
     RegMIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMIDR_EL1 copy()const
    {
     RegMIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMIDR_EL1: ";
            kout
                << "Revision = " << Revision << ", "
                << "PartNum = " << PartNum << ", "
                << "Architecture = " << Architecture << ", "
                << "Variant = " << Variant << ", "
                << "Implementer = " << Implementer << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMIDR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMIDR_EL1 make(uint32_t val)
    {
        RegMIDR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMIDR_EL1 read()
    {
        RegMIDR_EL1 res;
        __asm__ __volatile__("mrs %0,MIDR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMPIDR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t Aff0:8;
            uint64_t Aff1:8;
            uint64_t Aff2:8;
            uint64_t MT:1;
            uint64_t RES0_0:5;
            uint64_t U:1;
            uint64_t RES1_1:1;
            uint64_t Aff3:8;
            uint64_t RES0_2:24;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMPIDR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMPIDR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMPIDR_EL1 & setMandatoryFields()
    {
        Aff0 = 0;
        Aff1 = 0;
        Aff2 = 0;
        MT = 0;
        RES0_0 = 0;
        U = 0;
        RES1_1 = 1;
        Aff3 = 0;
        RES0_2 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMPIDR_EL1 copy()const volatile
    {
     RegMPIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMPIDR_EL1 copy()const
    {
     RegMPIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMPIDR_EL1: ";
            kout
                << "Aff0 = " << Aff0 << ", "
                << "Aff1 = " << Aff1 << ", "
                << "Aff2 = " << Aff2 << ", "
                << "MT = " << MT << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "U = " << U << ", "
                << "RES1_1 = " << RES1_1 << ", "
                << "Aff3 = " << Aff3 << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMPIDR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMPIDR_EL1 make(uint64_t val)
    {
        RegMPIDR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMPIDR_EL1 read()
    {
        RegMPIDR_EL1 res;
        __asm__ __volatile__("mrs %0,MPIDR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMPIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MPIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MPIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTTBR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t CnP:1;
            uint64_t BADDR:47;
            uint64_t ASID:16;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegTTBR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegTTBR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegTTBR0_EL1 & setMandatoryFields()
    {
        CnP = 0;
        BADDR = 0;
        ASID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegTTBR0_EL1 copy()const volatile
    {
     RegTTBR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegTTBR0_EL1 copy()const
    {
     RegTTBR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegTTBR0_EL1: ";
            kout
                << "CnP = " << CnP << ", "
                << "BADDR = " << Hex(BADDR) << ", "
                << "ASID = " << ASID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegTTBR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegTTBR0_EL1 make(uint64_t val)
    {
        RegTTBR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegTTBR0_EL1 read()
    {
        RegTTBR0_EL1 res;
        __asm__ __volatile__("mrs %0,TTBR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegTTBR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TTBR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr TTBR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTTBR1_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t CnP:1;
            uint64_t BADDR:47;
            uint64_t ASID:16;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegTTBR1_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegTTBR1_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegTTBR1_EL1 & setMandatoryFields()
    {
        CnP = 0;
        BADDR = 0;
        ASID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegTTBR1_EL1 copy()const volatile
    {
     RegTTBR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegTTBR1_EL1 copy()const
    {
     RegTTBR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegTTBR1_EL1: ";
            kout
                << "CnP = " << CnP << ", "
                << "BADDR = " << Hex(BADDR) << ", "
                << "ASID = " << ASID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegTTBR1_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegTTBR1_EL1 make(uint64_t val)
    {
        RegTTBR1_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegTTBR1_EL1 read()
    {
        RegTTBR1_EL1 res;
        __asm__ __volatile__("mrs %0,TTBR1_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegTTBR1_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TTBR1_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr TTBR1_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPAR_EL1
{
public:
    using ScaleType=uint64_t;
    union {
        struct {
            uint64_t F:1;
            uint64_t RES0_0:6;
            uint64_t SH:2;
            uint64_t NS:1;
            uint64_t IMP_DEF_1:1;
            uint64_t RES1_2:1;
            uint64_t PA47_12:36;
            uint64_t PA51_48:4;
            uint64_t RES0_3:4;
            uint64_t ATTR:8;
        }__attribute__((packed)) S0;
        struct {
            uint64_t F:1;
            uint64_t FST:6;
            uint64_t RES0_0:1;
            uint64_t PTW:1;
            uint64_t S:1;
            uint64_t RES0_1:1;
            uint64_t RES1_2:1;
            uint64_t RES0_3:36;
            uint64_t IMP_DEF0:4;
            uint64_t IMP_DEF1:4;
            uint64_t IMP_DEF2:8;
        }__attribute__((packed)) S1;
    };
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegPAR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegPAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegPAR_EL1 copy()const volatile
    {
     RegPAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegPAR_EL1 copy()const
    {
     RegPAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegPAR_EL1: ";
        if(S0.F==0)
        {
            kout
                << "S0.F = " << S0.F << ", "
                << "S0.RES0_0 = " << S0.RES0_0 << ", "
                << "S0.SH = " << S0.SH << ", "
                << "S0.NS = " << S0.NS << ", "
                << "S0.IMP_DEF_1 = " << S0.IMP_DEF_1 << ", "
                << "S0.RES1_2 = " << S0.RES1_2 << ", "
                << "S0.PA47_12 = " << Hex(S0.PA47_12) << ", "
                << "S0.PA51_48 = " << Hex(S0.PA51_48) << ", "
                << "S0.RES0_3 = " << S0.RES0_3 << ", "
                << "S0.ATTR = " << S0.ATTR << ", "
                << "\n";
        }
        else
        {
            kout
                << "S1.F = " << S1.F << ", "
                << "S1.FST = " << S1.FST << ", "
                << "S1.RES0_0 = " << S1.RES0_0 << ", "
                << "S1.PTW = " << S1.PTW << ", "
                << "S1.S = " << S1.S << ", "
                << "S1.RES0_1 = " << S1.RES0_1 << ", "
                << "S1.RES1_2 = " << S1.RES1_2 << ", "
                << "S1.RES0_3 = " << S1.RES0_3 << ", "
                << "S1.IMP_DEF0 = " << S1.IMP_DEF0 << ", "
                << "S1.IMP_DEF1 = " << S1.IMP_DEF1 << ", "
                << "S1.IMP_DEF2 = " << S1.IMP_DEF2 << ", "
                << "\n";
        }
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegPAR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegPAR_EL1 make(uint64_t val)
    {
        RegPAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegPAR_EL1 read()
    {
        RegPAR_EL1 res;
        __asm__ __volatile__("mrs %0,PAR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegPAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,PAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr PAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t Attr0:8;
            uint64_t Attr1:8;
            uint64_t Attr2:8;
            uint64_t Attr3:8;
            uint64_t Attr4:8;
            uint64_t Attr5:8;
            uint64_t Attr6:8;
            uint64_t Attr7:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMAIR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMAIR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMAIR_EL1 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMAIR_EL1 copy()const volatile
    {
     RegMAIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL1 copy()const
    {
     RegMAIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMAIR_EL1: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMAIR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMAIR_EL1 make(uint64_t val)
    {
        RegMAIR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMAIR_EL1 read()
    {
        RegMAIR_EL1 res;
        __asm__ __volatile__("mrs %0,MAIR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MAIR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t Attr0:8;
            uint64_t Attr1:8;
            uint64_t Attr2:8;
            uint64_t Attr3:8;
            uint64_t Attr4:8;
            uint64_t Attr5:8;
            uint64_t Attr6:8;
            uint64_t Attr7:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMAIR_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMAIR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMAIR_EL2 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMAIR_EL2 copy()const volatile
    {
     RegMAIR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL2 copy()const
    {
     RegMAIR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMAIR_EL2: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMAIR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMAIR_EL2 make(uint64_t val)
    {
        RegMAIR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMAIR_EL2 read()
    {
        RegMAIR_EL2 res;
        __asm__ __volatile__("mrs %0,MAIR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MAIR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t Attr0:8;
            uint64_t Attr1:8;
            uint64_t Attr2:8;
            uint64_t Attr3:8;
            uint64_t Attr4:8;
            uint64_t Attr5:8;
            uint64_t Attr6:8;
            uint64_t Attr7:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMAIR_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMAIR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMAIR_EL3 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMAIR_EL3 copy()const volatile
    {
     RegMAIR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL3 copy()const
    {
     RegMAIR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMAIR_EL3: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMAIR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMAIR_EL3 make(uint64_t val)
    {
        RegMAIR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMAIR_EL3 read()
    {
        RegMAIR_EL3 res;
        __asm__ __volatile__("mrs %0,MAIR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MAIR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSCTLR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t M:1;
            uint32_t A:1;
            uint32_t C:1;
            uint32_t SA:1;
            uint32_t SA0:1;
            uint32_t CP15BEN:1;
            uint32_t RES0_0:1;
            uint32_t ITD:1;
            uint32_t SED:1;
            uint32_t UMA:1;
            uint32_t RES0_1:1;
            uint32_t RES1_2:1;
            uint32_t I:1;
            uint32_t RES0_3:1;
            uint32_t DZE:1;
            uint32_t UCT:1;
            uint32_t nTWI:1;
            uint32_t RES0_4:1;
            uint32_t nTWE:1;
            uint32_t WXN:1;
            uint32_t RES1_5:1;
            uint32_t IESB:1;
            uint32_t RES1_6:1;
            uint32_t SPAN:1;
            uint32_t E0E:1;
            uint32_t EE:1;
            uint32_t UCI:1;
            uint32_t RES0_7:1;
            uint32_t nTLSMD:1;
            uint32_t LSMAOE:1;
            uint32_t RES0_8:2;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSCTLR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSCTLR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSCTLR_EL1 & setMandatoryFields()
    {
        M = 0;
        A = 0;
        C = 0;
        SA = 0;
        SA0 = 0;
        CP15BEN = 0;
        RES0_0 = 0;
        ITD = 0;
        SED = 0;
        UMA = 0;
        RES0_1 = 0;
        RES1_2 = 1;
        I = 0;
        RES0_3 = 0;
        DZE = 0;
        UCT = 0;
        nTWI = 0;
        RES0_4 = 0;
        nTWE = 0;
        WXN = 0;
        RES1_5 = 1;
        IESB = 0;
        RES1_6 = 1;
        SPAN = 0;
        E0E = 0;
        EE = 0;
        UCI = 0;
        RES0_7 = 0;
        nTLSMD = 0;
        LSMAOE = 0;
        RES0_8 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSCTLR_EL1 copy()const volatile
    {
     RegSCTLR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSCTLR_EL1 copy()const
    {
     RegSCTLR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSCTLR_EL1: ";
            kout
                << "M = " << M << ", "
                << "A = " << A << ", "
                << "C = " << C << ", "
                << "SA = " << SA << ", "
                << "SA0 = " << SA0 << ", "
                << "CP15BEN = " << CP15BEN << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "ITD = " << ITD << ", "
                << "SED = " << SED << ", "
                << "UMA = " << UMA << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "RES1_2 = " << RES1_2 << ", "
                << "I = " << I << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "DZE = " << DZE << ", "
                << "UCT = " << UCT << ", "
                << "nTWI = " << nTWI << ", "
                << "RES0_4 = " << RES0_4 << ", "
                << "nTWE = " << nTWE << ", "
                << "WXN = " << WXN << ", "
                << "RES1_5 = " << RES1_5 << ", "
                << "IESB = " << IESB << ", "
                << "RES1_6 = " << RES1_6 << ", "
                << "SPAN = " << SPAN << ", "
                << "E0E = " << E0E << ", "
                << "EE = " << EE << ", "
                << "UCI = " << UCI << ", "
                << "RES0_7 = " << RES0_7 << ", "
                << "nTLSMD = " << nTLSMD << ", "
                << "LSMAOE = " << LSMAOE << ", "
                << "RES0_8 = " << RES0_8 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSCTLR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSCTLR_EL1 make(uint32_t val)
    {
        RegSCTLR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSCTLR_EL1 read()
    {
        RegSCTLR_EL1 res;
        __asm__ __volatile__("mrs %0,SCTLR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSCTLR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SCTLR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SCTLR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDLR_EL0
{
public:
    using ScaleType=uint64_t;
            uint64_t RestartAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegDLR_EL0& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegDLR_EL0 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegDLR_EL0 & setMandatoryFields()
    {
        RestartAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegDLR_EL0 copy()const volatile
    {
     RegDLR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegDLR_EL0 copy()const
    {
     RegDLR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegDLR_EL0: ";
            kout
                << "RestartAddr = " << RestartAddr << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegDLR_EL0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegDLR_EL0 make(uint64_t val)
    {
        RegDLR_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegDLR_EL0 read()
    {
        RegDLR_EL0 res;
        __asm__ __volatile__("mrs %0,DLR_EL0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegDLR_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,DLR_EL0\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr DLR_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDSPSR_EL0
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegDSPSR_EL0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegDSPSR_EL0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegDSPSR_EL0 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegDSPSR_EL0 copy()const volatile
    {
     RegDSPSR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegDSPSR_EL0 copy()const
    {
     RegDSPSR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegDSPSR_EL0: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegDSPSR_EL0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegDSPSR_EL0 make(uint32_t val)
    {
        RegDSPSR_EL0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegDSPSR_EL0 read()
    {
        RegDSPSR_EL0 res;
        __asm__ __volatile__("mrs %0,DSPSR_EL0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegDSPSR_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,DSPSR_EL0\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr DSPSR_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/interrupt/GICCPUInterface.h" 2


template <int grp>
IntID GICCPUInterface::ack()
{
 return RegICC_IAR_EL1<grp>::read().INTID;
}
template <int grp>
void GICCPUInterface::eoi(IntID id)
{
 RegICC_EOIR_EL1<grp>::make(id & 0xFFFFFF).wrte();
}

template <int grp>
void GICCPUInterface::subPriorityBits(size_t n)
{
 if(n<1 || n>8)
  return;
 auto reg=RegICC_BPR_EL1<grp>::make(0);
 reg.BinaryPoint=n-1;
 reg.write();
}

template <int grp>
void GICCPUInterface::enableGroup(bool enable)
{
 auto en=RegICC_IGRPEN_EL1<grp>::make(0);
 en.Enable=enable;
 en.write();
}


template <int grp>
void GICCPUInterface::sgiTarget(IntID id,uint8_t aff3,uint8_t aff2,uint8_t aff1,uint8_t aff0)
{
 sgiTargetList<grp>(id, aff3, aff2, aff1, (0x1 << aff0));
}
template <int grp>
void GICCPUInterface::sgiSelf(IntID id)
{
 auto mpid = RegMPIDR_EL1::read();
 sgiTarget<grp>(id, mpid.Aff3, mpid.Aff2, mpid.Aff1, mpid.Aff0);
}
template <int grp>
void GICCPUInterface::sgiTargetList(IntID id,uint8_t aff3,uint8_t aff2,uint8_t aff1,uint16_t aff0Bits)
{
 auto sgir=RegICC_SGIR_EL1<grp>::make(0);
 sgir.Aff3= aff3;
 sgir.Aff2= aff2;
 sgir.Aff1= aff1;
 sgir.TargetList = aff0Bits;;
 sgir.INTID=id;
 sgir.IRM=RegICC_SGIR_EL1<grp>::IRMmode::ByAffinity;
 sgir.write();
}
template <int grp>
void GICCPUInterface::sgiAllOtherCPUs(IntID id)
{
 auto sgir=RegICC_SGIR_EL1<grp>::make(0);
 sgir.INTID=id;
 sgir.IRM=RegICC_SGIR_EL1<grp>::IRMmode::AllNoSelf;
 sgir.write();
}
# 73 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/GICCPUInterface.h" 2
# 9 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/interrupt/GICCPUInterface.cpp" 2


int GICCPUInterface::init(uint8_t lowestPriority,bool a3vEn,EOIMode mode)
{

 _ctrl.update();

 enableSystemRegister();
 lowestAllowedPriority(lowestPriority);


 _ctrl.A3V=a3vEn;
 _ctrl.EOImode=mode;
 _ctrl.write();


 enableGroup<0>(true);
 enableGroup<1>(true);

 return 0;
}

void GICCPUInterface::lowestAllowedPriority(uint8_t priorty)
{

 auto maskPrty = RegICC_PMR_EL1::make(0);
 maskPrty.Priortiy = priorty;
 maskPrty.write();
}

void GICCPUInterface::enableSystemRegister()
{
 auto sre = RegICC_SRE_EL1::read();
 sre.SRE=1;
 sre.write();
}
