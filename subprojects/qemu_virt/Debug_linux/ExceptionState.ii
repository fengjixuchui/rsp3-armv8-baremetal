# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/interrupt/ExceptionState.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "./cxx_macros.h" 1
# 32 "<command-line>" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/interrupt/ExceptionState.cpp"







# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/ExceptionState.h" 1
# 10 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/ExceptionState.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h" 1







# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 1 3
# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 3
       
# 43 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 3






# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 1 3
# 229 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3

# 229 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 251 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 533 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/os_defines.h" 1 3
# 534 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 2 3


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/cpu_defines.h" 1 3
# 537 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 2 3
# 50 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 2 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 1 3 4
# 149 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 216 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 426 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 51 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 2 3


namespace std
{

  using ::max_align_t;
}
# 9 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h" 2
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 1 3
# 32 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 3
       
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 3
# 41 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint.h" 1 3 4
# 11 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint.h" 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint-gcc.h" 1 3 4
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint-gcc.h" 3 4
typedef signed char int8_t;


typedef short int int16_t;


typedef int int32_t;


typedef long int int64_t;


typedef unsigned char uint8_t;


typedef short unsigned int uint16_t;


typedef unsigned int uint32_t;


typedef long unsigned int uint64_t;




typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef short unsigned int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef long unsigned int uint_least64_t;



typedef int int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned int uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef long unsigned int uint_fast64_t;




typedef long int intptr_t;


typedef long unsigned int uintptr_t;




typedef long int intmax_t;
typedef long unsigned int uintmax_t;
# 12 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint.h" 2 3 4
# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 10 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h" 2
# 22 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h"

# 22 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h"
extern const char EMPTY_STR[1];



constexpr int UNIT_K=1024;
constexpr int KiB = UNIT_K;
constexpr int MiB = UNIT_K * KiB;
constexpr int GiB = UNIT_K * MiB;
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/ExceptionState.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/system_common_registers.h" 1






# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h" 1
# 14 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h"
size_t printk(char ch);


size_t printk(const char *s);

size_t printk(const char *s,size_t n);


void flush();




# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/printk.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/printk.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/printk.h" 2
# 28 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h" 2
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/runtime_def.h" 1
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h" 2

class Output{
public:
 size_t print(const char *s,size_t len);
 size_t print(const char *s);
 Output & operator<<(char ch);

 Output & operator<<(uint8_t u);
 Output & operator<<(uint16_t u);
 Output & operator<<(uint32_t u);
 Output & operator<<(bool i);
 Output & operator<<(short i);
 Output & operator<<(int i);
 Output & operator<<(double d);
 Output & operator<<(const char *s);
 Output & operator<<(size_t i);
 Output & operator<<(const void *p);
 Output & operator<<(const volatile void *p);
 Output & flush();
};



extern Output kout;


constexpr size_t koutBufSize = 65;
extern char koutBuf[koutBufSize];
# 8 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/system_common_registers.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h" 1
# 15 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h"
template <int Base>
class IntegerFormatter{
public:
 IntegerFormatter(size_t num);
 IntegerFormatter(const void *p);
 char *format()const;
private:
 size_t num;
};


using Hex=IntegerFormatter<16>;
using Dec=IntegerFormatter<10>;
using Bin=IntegerFormatter<2>;

template <int Base>
Output & operator<<(Output & out,const IntegerFormatter<Base> &hf);



# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic_util.h" 1
# 17 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic_util.h"
extern const char digitsMap[];



size_t itob(size_t i,char *dst,size_t size);
size_t itod(size_t i,char *dst,size_t size);
size_t itox(size_t i,char *dst,size_t size);

size_t itos(size_t i,unsigned int base,char *dst,size_t size);


uint64_t alignAhead(uint64_t d,uint64_t alignment);
uint64_t alignBackward(uint64_t d,uint64_t alignment);





void reverse(char *str,size_t size);



const char *strOffset(const char *p,size_t offset);

namespace{

 template <size_t bit,size_t ... bits>
 struct BitMaskStruct{
  static constexpr size_t value= BitMaskStruct<bit>::value|BitMaskStruct<bits...>::value;
 };
 template <size_t bit>
 struct BitMaskStruct<bit>{
  static constexpr size_t value=(1u<<bit);
 };

}




template <uint8_t...bit>
__attribute__((always_inline)) inline size_t bitMask()
{
 return BitMaskStruct<bit...>::value;
}


template <size_t ... bit>
__attribute__((always_inline)) inline constexpr size_t bitOnes()
{
 return BitMaskStruct<bit...>::value;
}

template <size_t ...bit>
__attribute__((always_inline)) inline constexpr size_t bitZeros()
{
 return ~(BitMaskStruct<bit...>::value);
}

template <size_t ...bit,class T>
__attribute__((always_inline)) inline T bitsSet(T t)
{
 return t | bitOnes<bit...>();
}

template <size_t ...bit,class T>
__attribute__((always_inline)) inline T bitsClear(T t)
{
 return (t & bitZeros<bit...>());
}


template <size_t ...bit,class T>
__attribute__((always_inline)) inline T bitsKept(T t)
{
 return (t & bitOnes<bit...>());
}
template <size_t ...bit,class T>
__attribute__((always_inline)) inline bool bitsAnySet(T t)
{
 return bitsKept<bit...>(t);
}
template <size_t ...bit,class T>
__attribute__((always_inline)) inline bool bitsNonSet(T t)
{
 return !bitsAnySet<bit...>(t);
}



template <size_t ...bitsAsOne,class VoidT,size_t ...bitsAsZero>
__attribute__((always_inline)) inline size_t bitsMix0()
{
 return bitsClear<bitsAsZero...>(bitsSet<bitsAsOne...>(static_cast<size_t>(0)));
}

template <size_t ...bitsAsOne,class VoidT,size_t ...bitsAsZero>
__attribute__((always_inline)) inline size_t bitsMix1()
{
 return bitsClear<bitsAsZero...>(bitsSet<bitsAsOne...>(static_cast<size_t>(0xffffffffffffffffUL)));
}

__attribute__((always_inline)) inline uint64_t bitMask(uint8_t bit)
{
 return (1u << bit);
}
template <uint64_t i>
__attribute__((always_inline)) inline uint64_t upperMaskBits()
{
 return 0xffffffffffffffff >> (64-i) << (64-i);
}
template <uint64_t i>
__attribute__((always_inline)) inline uint64_t lowerMaskBits()
{
 return 0xffffffffffffffff << (64-i) >> (64-i);
}

__attribute__((always_inline)) inline uint64_t upperMaskBits(uint64_t i)
{
 return 0xffffffffffffffff >> (64-i) << (64-i);
}

__attribute__((always_inline)) inline uint64_t lowerMaskBits(uint64_t i)
{
 return 0xffffffffffffffff << (64-i) >> (64-i);
}
__attribute__((always_inline)) inline uint64_t middleMaskBits(uint64_t lowerBound,uint64_t upperBound)
{

 return 0xffffffffffffffff >> lowerBound << (64 - upperBound - 1 + lowerBound) >> (64-upperBound -1);
}


template <class Type,class ValueType>
__attribute__((always_inline)) inline void setBits(Type & i, uint8_t lowerBound,uint8_t upperBound,ValueType v)
{

 i = (i & (~middleMaskBits(lowerBound, upperBound))) |((v & lowerMaskBits(upperBound - lowerBound + 1))<<lowerBound );
}
__attribute__((always_inline)) inline uint64_t getBits(uint64_t i, uint8_t lowerBound,uint8_t upperBound)
{
 return (i>>lowerBound)&lowerMaskBits(upperBound - lowerBound + 1);
}
# 175 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic_util.h"
template <class Type,class ValueType>
__attribute__((always_inline)) inline void setBit(Type & i,uint8_t index,ValueType v)
{
 setBits(i,index,index,v);
}
__attribute__((always_inline)) inline uint64_t getBit(uint64_t i,uint8_t index)
{
 return getBits(i,index,index);
}
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h" 2


template <int Base>
IntegerFormatter<Base>::IntegerFormatter(size_t num)
 :num(num){}

template <int Base>
IntegerFormatter<Base>::IntegerFormatter(const void *p)
 :num(reinterpret_cast<size_t>(p)){}

template <int Base>
char *IntegerFormatter<Base>::format()const
{
 itos(num, Base, koutBuf, koutBufSize);
 return koutBuf;
}

template <int Base>
Output & operator<<(Output &out,const IntegerFormatter<Base> &hf)
{
 out << hf.format();
 return out;
}
# 36 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h" 2
# 9 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/system_common_registers.h" 2

class RegCurrentEL
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:2;
            uint32_t EL:2;
            uint32_t RES0_1:28;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegCurrentEL& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegCurrentEL & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegCurrentEL & setMandatoryFields()
    {
        RES0_0 = 0;
        EL = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegCurrentEL copy()const volatile
    {
     RegCurrentEL res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegCurrentEL copy()const
    {
     RegCurrentEL res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegCurrentEL: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegCurrentEL*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegCurrentEL make(uint32_t val)
    {
        RegCurrentEL res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegCurrentEL read()
    {
        RegCurrentEL res;
        __asm__ __volatile__("mrs %0,CurrentEL\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegCurrentEL & update()
    {
        __asm__ __volatile__("mrs %0,CurrentEL\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr CurrentEL,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDAIF
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:6;
            uint32_t F:1;
            uint32_t I:1;
            uint32_t A:1;
            uint32_t D:1;
            uint32_t RES0_1:22;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegDAIF& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegDAIF & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegDAIF & setMandatoryFields()
    {
        RES0_0 = 0;
        F = 0;
        I = 0;
        A = 0;
        D = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegDAIF copy()const volatile
    {
     RegDAIF res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegDAIF copy()const
    {
     RegDAIF res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegDAIF: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "F = " << F << ", "
                << "I = " << I << ", "
                << "A = " << A << ", "
                << "D = " << D << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegDAIF*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegDAIF make(uint32_t val)
    {
        RegDAIF res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegDAIF read()
    {
        RegDAIF res;
        __asm__ __volatile__("mrs %0,DAIF\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegDAIF & update()
    {
        __asm__ __volatile__("mrs %0,DAIF\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr DAIF,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegVBAR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t Addr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegVBAR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegVBAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegVBAR_EL1 & setMandatoryFields()
    {
        Addr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegVBAR_EL1 copy()const volatile
    {
     RegVBAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegVBAR_EL1 copy()const
    {
     RegVBAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegVBAR_EL1: ";
            kout
                << "Addr = " << Hex(Addr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegVBAR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegVBAR_EL1 make(uint64_t val)
    {
        RegVBAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegVBAR_EL1 read()
    {
        RegVBAR_EL1 res;
        __asm__ __volatile__("mrs %0,VBAR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegVBAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,VBAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr VBAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t returnAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegELR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegELR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegELR_EL1 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegELR_EL1 copy()const volatile
    {
     RegELR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegELR_EL1 copy()const
    {
     RegELR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegELR_EL1: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegELR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegELR_EL1 make(uint64_t val)
    {
        RegELR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegELR_EL1 read()
    {
        RegELR_EL1 res;
        __asm__ __volatile__("mrs %0,ELR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegELR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ELR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t returnAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegELR_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegELR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegELR_EL2 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegELR_EL2 copy()const volatile
    {
     RegELR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegELR_EL2 copy()const
    {
     RegELR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegELR_EL2: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegELR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegELR_EL2 make(uint64_t val)
    {
        RegELR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegELR_EL2 read()
    {
        RegELR_EL2 res;
        __asm__ __volatile__("mrs %0,ELR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegELR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ELR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t returnAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegELR_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegELR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegELR_EL3 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegELR_EL3 copy()const volatile
    {
     RegELR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegELR_EL3 copy()const
    {
     RegELR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegELR_EL3: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegELR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegELR_EL3 make(uint64_t val)
    {
        RegELR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegELR_EL3 read()
    {
        RegELR_EL3 res;
        __asm__ __volatile__("mrs %0,ELR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegELR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ELR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t ISS:25;
            uint32_t IL:1;
            uint32_t EC:6;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegESR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegESR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegESR_EL1 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegESR_EL1 copy()const volatile
    {
     RegESR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegESR_EL1 copy()const
    {
     RegESR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegESR_EL1: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegESR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegESR_EL1 make(uint32_t val)
    {
        RegESR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegESR_EL1 read()
    {
        RegESR_EL1 res;
        __asm__ __volatile__("mrs %0,ESR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegESR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ESR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL2
{
public:
    using ScaleType=uint32_t;
            uint32_t ISS:25;
            uint32_t IL:1;
            uint32_t EC:6;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegESR_EL2& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegESR_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegESR_EL2 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegESR_EL2 copy()const volatile
    {
     RegESR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegESR_EL2 copy()const
    {
     RegESR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegESR_EL2: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegESR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegESR_EL2 make(uint32_t val)
    {
        RegESR_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegESR_EL2 read()
    {
        RegESR_EL2 res;
        __asm__ __volatile__("mrs %0,ESR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegESR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ESR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL3
{
public:
    using ScaleType=uint32_t;
            uint32_t ISS:25;
            uint32_t IL:1;
            uint32_t EC:6;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegESR_EL3& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegESR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegESR_EL3 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegESR_EL3 copy()const volatile
    {
     RegESR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegESR_EL3 copy()const
    {
     RegESR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegESR_EL3: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegESR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegESR_EL3 make(uint32_t val)
    {
        RegESR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegESR_EL3 read()
    {
        RegESR_EL3 res;
        __asm__ __volatile__("mrs %0,ESR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegESR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ESR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t faultAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegFAR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegFAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegFAR_EL1 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegFAR_EL1 copy()const volatile
    {
     RegFAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL1 copy()const
    {
     RegFAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegFAR_EL1: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegFAR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegFAR_EL1 make(uint64_t val)
    {
        RegFAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegFAR_EL1 read()
    {
        RegFAR_EL1 res;
        __asm__ __volatile__("mrs %0,FAR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr FAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t faultAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegFAR_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegFAR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegFAR_EL2 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegFAR_EL2 copy()const volatile
    {
     RegFAR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL2 copy()const
    {
     RegFAR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegFAR_EL2: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegFAR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegFAR_EL2 make(uint64_t val)
    {
        RegFAR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegFAR_EL2 read()
    {
        RegFAR_EL2 res;
        __asm__ __volatile__("mrs %0,FAR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr FAR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t faultAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegFAR_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegFAR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegFAR_EL3 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegFAR_EL3 copy()const volatile
    {
     RegFAR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL3 copy()const
    {
     RegFAR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegFAR_EL3: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegFAR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegFAR_EL3 make(uint64_t val)
    {
        RegFAR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegFAR_EL3 read()
    {
        RegFAR_EL3 res;
        __asm__ __volatile__("mrs %0,FAR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr FAR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSR_EL1 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSR_EL1 copy()const volatile
    {
     RegSPSR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL1 copy()const
    {
     RegSPSR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSR_EL1: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSR_EL1 make(uint32_t val)
    {
        RegSPSR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSR_EL1 read()
    {
        RegSPSR_EL1 res;
        __asm__ __volatile__("mrs %0,SPSR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL2
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSR_EL2& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSR_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSR_EL2 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSR_EL2 copy()const volatile
    {
     RegSPSR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL2 copy()const
    {
     RegSPSR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSR_EL2: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSR_EL2 make(uint32_t val)
    {
        RegSPSR_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSR_EL2 read()
    {
        RegSPSR_EL2 res;
        __asm__ __volatile__("mrs %0,SPSR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL3
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSR_EL3& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSR_EL3 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSR_EL3 copy()const volatile
    {
     RegSPSR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL3 copy()const
    {
     RegSPSR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSR_EL3: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSR_EL3 make(uint32_t val)
    {
        RegSPSR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSR_EL3 read()
    {
        RegSPSR_EL3 res;
        __asm__ __volatile__("mrs %0,SPSR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP copy()const volatile
    {
     RegSP res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP copy()const
    {
     RegSP res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP make(uint64_t val)
    {
        RegSP res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP read()
    {
        RegSP res;
        __asm__ __volatile__("mrs %0,SP\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP & update()
    {
        __asm__ __volatile__("mrs %0,SP\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL0
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL0& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL0 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL0 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL0 copy()const volatile
    {
     RegSP_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL0 copy()const
    {
     RegSP_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL0: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL0 make(uint64_t val)
    {
        RegSP_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL0 read()
    {
        RegSP_EL0 res;
        __asm__ __volatile__("mrs %0,SP_EL0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL0\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL1 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL1 copy()const volatile
    {
     RegSP_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL1 copy()const
    {
     RegSP_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL1: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL1 make(uint64_t val)
    {
        RegSP_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL1 read()
    {
        RegSP_EL1 res;
        __asm__ __volatile__("mrs %0,SP_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL2 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL2 copy()const volatile
    {
     RegSP_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL2 copy()const
    {
     RegSP_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL2: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL2 make(uint64_t val)
    {
        RegSP_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL2 read()
    {
        RegSP_EL2 res;
        __asm__ __volatile__("mrs %0,SP_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL3 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL3 copy()const volatile
    {
     RegSP_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL3 copy()const
    {
     RegSP_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL3: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL3 make(uint64_t val)
    {
        RegSP_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL3 read()
    {
        RegSP_EL3 res;
        __asm__ __volatile__("mrs %0,SP_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegNZCV
{
public:
    using ScaleType=uint64_t;
            uint64_t RES0_0:28;
            uint64_t V:1;
            uint64_t C:1;
            uint64_t Z:1;
            uint64_t N:1;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegNZCV& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegNZCV & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegNZCV & setMandatoryFields()
    {
        RES0_0 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegNZCV copy()const volatile
    {
     RegNZCV res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegNZCV copy()const
    {
     RegNZCV res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegNZCV: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegNZCV*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegNZCV make(uint64_t val)
    {
        RegNZCV res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegNZCV read()
    {
        RegNZCV res;
        __asm__ __volatile__("mrs %0,NZCV\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegNZCV & update()
    {
        __asm__ __volatile__("mrs %0,NZCV\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr NZCV,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPAN
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:22;
            uint32_t PAN:1;
            uint32_t RES0_1:9;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegPAN& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegPAN & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegPAN & setMandatoryFields()
    {
        RES0_0 = 0;
        PAN = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegPAN copy()const volatile
    {
     RegPAN res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegPAN copy()const
    {
     RegPAN res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegPAN: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "PAN = " << PAN << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegPAN*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegPAN make(uint32_t val)
    {
        RegPAN res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegPAN read()
    {
        RegPAN res;
        __asm__ __volatile__("mrs %0,PAN\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegPAN & update()
    {
        __asm__ __volatile__("mrs %0,PAN\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr PAN,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSel
{
public:
    using ScaleType=uint32_t;
            uint32_t SP:1;
            uint32_t RES0_0:31;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSel& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSel & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSel & setMandatoryFields()
    {
        SP = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSel copy()const volatile
    {
     RegSPSel res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSel copy()const
    {
     RegSPSel res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSel: ";
            kout
                << "SP = " << SP << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSel*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSel make(uint32_t val)
    {
        RegSPSel res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSel read()
    {
        RegSPSel res;
        __asm__ __volatile__("mrs %0,SPSel\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSel & update()
    {
        __asm__ __volatile__("mrs %0,SPSel\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSel,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegUAO
{
public:
    using ScaleType=uint64_t;
            uint64_t RES0_0:23;
            uint64_t UAO:1;
            uint64_t RES0_1:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegUAO& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegUAO & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegUAO & setMandatoryFields()
    {
        RES0_0 = 0;
        UAO = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegUAO copy()const volatile
    {
     RegUAO res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegUAO copy()const
    {
     RegUAO res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegUAO: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "UAO = " << UAO << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegUAO*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegUAO make(uint64_t val)
    {
        RegUAO res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegUAO read()
    {
        RegUAO res;
        __asm__ __volatile__("mrs %0,UAO\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegUAO & update()
    {
        __asm__ __volatile__("mrs %0,UAO\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr UAO,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPC
{
public:
    using ScaleType=uint64_t;
            uint64_t PC:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegPC& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegPC & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegPC & setMandatoryFields()
    {
        PC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegPC copy()const volatile
    {
     RegPC res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegPC copy()const
    {
     RegPC res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegPC: ";
            kout
                << "PC = " << Hex(PC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegPC*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegPC make(uint64_t val)
    {
        RegPC res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegPC read()
    {
        RegPC res;
        __asm__ __volatile__("mrs %0,PC\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegPC & update()
    {
        __asm__ __volatile__("mrs %0,PC\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr PC,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTCR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t T0SZ:6;
            uint64_t RES0_0:1;
            uint64_t EPD0:1;
            uint64_t IRGN0:2;
            uint64_t ORGN0:2;
            uint64_t SH0:2;
            uint64_t TG0:2;
            uint64_t T1SZ:6;
            uint64_t A1:1;
            uint64_t EPD1:1;
            uint64_t IRGN1:2;
            uint64_t ORGN1:2;
            uint64_t SH1:2;
            uint64_t TG1:2;
            uint64_t IPS:3;
            uint64_t RES0_1:1;
            uint64_t AS:1;
            uint64_t TBI0:1;
            uint64_t TBI1:1;
            uint64_t HA:1;
            uint64_t HD:1;
            uint64_t HPD0:1;
            uint64_t HPD1:1;
            uint64_t HWU059:1;
            uint64_t HWU060:1;
            uint64_t HWU061:1;
            uint64_t HWU062:1;
            uint64_t HWU159:1;
            uint64_t HWU160:1;
            uint64_t HWU161:1;
            uint64_t HWU162:1;
            uint64_t RES0_2:2;
            uint64_t NFD0:1;
            uint64_t NFD1:1;
            uint64_t RES0_3:9;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegTCR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegTCR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegTCR_EL1 & setMandatoryFields()
    {
        T0SZ = 0;
        RES0_0 = 0;
        EPD0 = 0;
        IRGN0 = 0;
        ORGN0 = 0;
        SH0 = 0;
        TG0 = 0;
        T1SZ = 0;
        A1 = 0;
        EPD1 = 0;
        IRGN1 = 0;
        ORGN1 = 0;
        SH1 = 0;
        TG1 = 0;
        IPS = 0;
        RES0_1 = 0;
        AS = 0;
        TBI0 = 0;
        TBI1 = 0;
        HA = 0;
        HD = 0;
        HPD0 = 0;
        HPD1 = 0;
        HWU059 = 0;
        HWU060 = 0;
        HWU061 = 0;
        HWU062 = 0;
        HWU159 = 0;
        HWU160 = 0;
        HWU161 = 0;
        HWU162 = 0;
        RES0_2 = 0;
        NFD0 = 0;
        NFD1 = 0;
        RES0_3 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegTCR_EL1 copy()const volatile
    {
     RegTCR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegTCR_EL1 copy()const
    {
     RegTCR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegTCR_EL1: ";
            kout
                << "T0SZ = " << T0SZ << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EPD0 = " << EPD0 << ", "
                << "IRGN0 = " << IRGN0 << ", "
                << "ORGN0 = " << ORGN0 << ", "
                << "SH0 = " << SH0 << ", "
                << "TG0 = " << TG0 << ", "
                << "T1SZ = " << T1SZ << ", "
                << "A1 = " << A1 << ", "
                << "EPD1 = " << EPD1 << ", "
                << "IRGN1 = " << IRGN1 << ", "
                << "ORGN1 = " << ORGN1 << ", "
                << "SH1 = " << SH1 << ", "
                << "TG1 = " << TG1 << ", "
                << "IPS = " << IPS << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "AS = " << AS << ", "
                << "TBI0 = " << TBI0 << ", "
                << "TBI1 = " << TBI1 << ", "
                << "HA = " << HA << ", "
                << "HD = " << HD << ", "
                << "HPD0 = " << HPD0 << ", "
                << "HPD1 = " << HPD1 << ", "
                << "HWU059 = " << HWU059 << ", "
                << "HWU060 = " << HWU060 << ", "
                << "HWU061 = " << HWU061 << ", "
                << "HWU062 = " << HWU062 << ", "
                << "HWU159 = " << HWU159 << ", "
                << "HWU160 = " << HWU160 << ", "
                << "HWU161 = " << HWU161 << ", "
                << "HWU162 = " << HWU162 << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "NFD0 = " << NFD0 << ", "
                << "NFD1 = " << NFD1 << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegTCR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegTCR_EL1 make(uint64_t val)
    {
        RegTCR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegTCR_EL1 read()
    {
        RegTCR_EL1 res;
        __asm__ __volatile__("mrs %0,TCR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegTCR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TCR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr TCR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegISR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:6;
            uint32_t F:1;
            uint32_t I:1;
            uint32_t A:1;
            uint32_t RES0_1:23;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegISR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegISR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegISR_EL1 & setMandatoryFields()
    {
        RES0_0 = 0;
        F = 0;
        I = 0;
        A = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegISR_EL1 copy()const volatile
    {
     RegISR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegISR_EL1 copy()const
    {
     RegISR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegISR_EL1: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "F = " << F << ", "
                << "I = " << I << ", "
                << "A = " << A << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegISR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegISR_EL1 make(uint32_t val)
    {
        RegISR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegISR_EL1 read()
    {
        RegISR_EL1 res;
        __asm__ __volatile__("mrs %0,ISR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegISR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ISR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ISR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64ISAR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t RES0_0:4;
            uint64_t AES:4;
            uint64_t SHA1:4;
            uint64_t SHA2:4;
            uint64_t CRC32:4;
            uint64_t Atomic:4;
            uint64_t RES0_1:4;
            uint64_t RDM:4;
            uint64_t SHA3:4;
            uint64_t SM3:4;
            uint64_t SM4:4;
            uint64_t DP:4;
            uint64_t RES0_2:16;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64ISAR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 & setMandatoryFields()
    {
        RES0_0 = 0;
        AES = 0;
        SHA1 = 0;
        SHA2 = 0;
        CRC32 = 0;
        Atomic = 0;
        RES0_1 = 0;
        RDM = 0;
        SHA3 = 0;
        SM3 = 0;
        SM4 = 0;
        DP = 0;
        RES0_2 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 copy()const volatile
    {
     RegID_AA64ISAR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 copy()const
    {
     RegID_AA64ISAR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64ISAR0_EL1: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "AES = " << AES << ", "
                << "SHA1 = " << SHA1 << ", "
                << "SHA2 = " << SHA2 << ", "
                << "CRC32 = " << CRC32 << ", "
                << "Atomic = " << Atomic << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "RDM = " << RDM << ", "
                << "SHA3 = " << SHA3 << ", "
                << "SM3 = " << SM3 << ", "
                << "SM4 = " << SM4 << ", "
                << "DP = " << DP << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64ISAR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64ISAR0_EL1 make(uint64_t val)
    {
        RegID_AA64ISAR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64ISAR0_EL1 read()
    {
        RegID_AA64ISAR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64ISAR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64ISAR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64ISAR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegCONTEXTIDR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t PROCID:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegCONTEXTIDR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 & setMandatoryFields()
    {
        PROCID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 copy()const volatile
    {
     RegCONTEXTIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 copy()const
    {
     RegCONTEXTIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegCONTEXTIDR_EL1: ";
            kout
                << "PROCID = " << PROCID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegCONTEXTIDR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegCONTEXTIDR_EL1 make(uint32_t val)
    {
        RegCONTEXTIDR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegCONTEXTIDR_EL1 read()
    {
        RegCONTEXTIDR_EL1 res;
        __asm__ __volatile__("mrs %0,CONTEXTIDR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,CONTEXTIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr CONTEXTIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64PFR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t EL0:4;
            uint64_t EL1:4;
            uint64_t EL2:4;
            uint64_t EL3:4;
            uint64_t FP:4;
            uint64_t AdvSIMD:4;
            uint64_t GIC:4;
            uint64_t RAS:4;
            uint64_t SVE:4;
            uint64_t RES0_0:28;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64PFR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 & setMandatoryFields()
    {
        EL0 = 0;
        EL1 = 0;
        EL2 = 0;
        EL3 = 0;
        FP = 0;
        AdvSIMD = 0;
        GIC = 0;
        RAS = 0;
        SVE = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 copy()const volatile
    {
     RegID_AA64PFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 copy()const
    {
     RegID_AA64PFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64PFR0_EL1: ";
            kout
                << "EL0 = " << EL0 << ", "
                << "EL1 = " << EL1 << ", "
                << "EL2 = " << EL2 << ", "
                << "EL3 = " << EL3 << ", "
                << "FP = " << FP << ", "
                << "AdvSIMD = " << AdvSIMD << ", "
                << "GIC = " << GIC << ", "
                << "RAS = " << RAS << ", "
                << "SVE = " << SVE << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64PFR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64PFR0_EL1 make(uint64_t val)
    {
        RegID_AA64PFR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64PFR0_EL1 read()
    {
        RegID_AA64PFR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64PFR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64PFR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64PFR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64MMFR1_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t HAFDBS:4;
            uint64_t VMIDBits:4;
            uint64_t VH:4;
            uint64_t HPDS:4;
            uint64_t LO:4;
            uint64_t PAN:4;
            uint64_t SpecSEI:4;
            uint64_t XNX:4;
            uint64_t RES0_0:32;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64MMFR1_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 & setMandatoryFields()
    {
        HAFDBS = 0;
        VMIDBits = 0;
        VH = 0;
        HPDS = 0;
        LO = 0;
        PAN = 0;
        SpecSEI = 0;
        XNX = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 copy()const volatile
    {
     RegID_AA64MMFR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 copy()const
    {
     RegID_AA64MMFR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64MMFR1_EL1: ";
            kout
                << "HAFDBS = " << HAFDBS << ", "
                << "VMIDBits = " << VMIDBits << ", "
                << "VH = " << VH << ", "
                << "HPDS = " << HPDS << ", "
                << "LO = " << LO << ", "
                << "PAN = " << PAN << ", "
                << "SpecSEI = " << SpecSEI << ", "
                << "XNX = " << XNX << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64MMFR1_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR1_EL1 make(uint64_t val)
    {
        RegID_AA64MMFR1_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR1_EL1 read()
    {
        RegID_AA64MMFR1_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64MMFR1_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64MMFR1_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64MMFR1_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64MMFR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t PARange:4;
            uint64_t ASIDBits:4;
            uint64_t BigEnd:4;
            uint64_t SNSMem:4;
            uint64_t BigEndEL0:4;
            uint64_t TGran16:4;
            uint64_t TGran64:4;
            uint64_t TGran4:4;
            uint64_t RES0_0:32;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64MMFR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 & setMandatoryFields()
    {
        PARange = 0;
        ASIDBits = 0;
        BigEnd = 0;
        SNSMem = 0;
        BigEndEL0 = 0;
        TGran16 = 0;
        TGran64 = 0;
        TGran4 = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 copy()const volatile
    {
     RegID_AA64MMFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 copy()const
    {
     RegID_AA64MMFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64MMFR0_EL1: ";
            kout
                << "PARange = " << PARange << ", "
                << "ASIDBits = " << ASIDBits << ", "
                << "BigEnd = " << BigEnd << ", "
                << "SNSMem = " << SNSMem << ", "
                << "BigEndEL0 = " << BigEndEL0 << ", "
                << "TGran16 = " << Hex(TGran16) << ", "
                << "TGran64 = " << Hex(TGran64) << ", "
                << "TGran4 = " << Hex(TGran4) << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64MMFR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR0_EL1 make(uint64_t val)
    {
        RegID_AA64MMFR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR0_EL1 read()
    {
        RegID_AA64MMFR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64MMFR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64MMFR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64MMFR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMIDR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t Revision:4;
            uint32_t PartNum:12;
            uint32_t Architecture:4;
            uint32_t Variant:4;
            uint32_t Implementer:8;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegMIDR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMIDR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMIDR_EL1 & setMandatoryFields()
    {
        Revision = 0;
        PartNum = 0;
        Architecture = 0;
        Variant = 0;
        Implementer = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMIDR_EL1 copy()const volatile
    {
     RegMIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMIDR_EL1 copy()const
    {
     RegMIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMIDR_EL1: ";
            kout
                << "Revision = " << Revision << ", "
                << "PartNum = " << PartNum << ", "
                << "Architecture = " << Architecture << ", "
                << "Variant = " << Variant << ", "
                << "Implementer = " << Implementer << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMIDR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMIDR_EL1 make(uint32_t val)
    {
        RegMIDR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMIDR_EL1 read()
    {
        RegMIDR_EL1 res;
        __asm__ __volatile__("mrs %0,MIDR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMPIDR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t Aff0:8;
            uint64_t Aff1:8;
            uint64_t Aff2:8;
            uint64_t MT:1;
            uint64_t RES0_0:5;
            uint64_t U:1;
            uint64_t RES1_1:1;
            uint64_t Aff3:8;
            uint64_t RES0_2:24;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMPIDR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMPIDR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMPIDR_EL1 & setMandatoryFields()
    {
        Aff0 = 0;
        Aff1 = 0;
        Aff2 = 0;
        MT = 0;
        RES0_0 = 0;
        U = 0;
        RES1_1 = 1;
        Aff3 = 0;
        RES0_2 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMPIDR_EL1 copy()const volatile
    {
     RegMPIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMPIDR_EL1 copy()const
    {
     RegMPIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMPIDR_EL1: ";
            kout
                << "Aff0 = " << Aff0 << ", "
                << "Aff1 = " << Aff1 << ", "
                << "Aff2 = " << Aff2 << ", "
                << "MT = " << MT << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "U = " << U << ", "
                << "RES1_1 = " << RES1_1 << ", "
                << "Aff3 = " << Aff3 << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMPIDR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMPIDR_EL1 make(uint64_t val)
    {
        RegMPIDR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMPIDR_EL1 read()
    {
        RegMPIDR_EL1 res;
        __asm__ __volatile__("mrs %0,MPIDR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMPIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MPIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MPIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTTBR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t CnP:1;
            uint64_t BADDR:47;
            uint64_t ASID:16;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegTTBR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegTTBR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegTTBR0_EL1 & setMandatoryFields()
    {
        CnP = 0;
        BADDR = 0;
        ASID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegTTBR0_EL1 copy()const volatile
    {
     RegTTBR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegTTBR0_EL1 copy()const
    {
     RegTTBR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegTTBR0_EL1: ";
            kout
                << "CnP = " << CnP << ", "
                << "BADDR = " << Hex(BADDR) << ", "
                << "ASID = " << ASID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegTTBR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegTTBR0_EL1 make(uint64_t val)
    {
        RegTTBR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegTTBR0_EL1 read()
    {
        RegTTBR0_EL1 res;
        __asm__ __volatile__("mrs %0,TTBR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegTTBR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TTBR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr TTBR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTTBR1_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t CnP:1;
            uint64_t BADDR:47;
            uint64_t ASID:16;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegTTBR1_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegTTBR1_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegTTBR1_EL1 & setMandatoryFields()
    {
        CnP = 0;
        BADDR = 0;
        ASID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegTTBR1_EL1 copy()const volatile
    {
     RegTTBR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegTTBR1_EL1 copy()const
    {
     RegTTBR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegTTBR1_EL1: ";
            kout
                << "CnP = " << CnP << ", "
                << "BADDR = " << Hex(BADDR) << ", "
                << "ASID = " << ASID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegTTBR1_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegTTBR1_EL1 make(uint64_t val)
    {
        RegTTBR1_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegTTBR1_EL1 read()
    {
        RegTTBR1_EL1 res;
        __asm__ __volatile__("mrs %0,TTBR1_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegTTBR1_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TTBR1_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr TTBR1_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPAR_EL1
{
public:
    using ScaleType=uint64_t;
    union {
        struct {
            uint64_t F:1;
            uint64_t RES0_0:6;
            uint64_t SH:2;
            uint64_t NS:1;
            uint64_t IMP_DEF_1:1;
            uint64_t RES1_2:1;
            uint64_t PA47_12:36;
            uint64_t PA51_48:4;
            uint64_t RES0_3:4;
            uint64_t ATTR:8;
        }__attribute__((packed)) S0;
        struct {
            uint64_t F:1;
            uint64_t FST:6;
            uint64_t RES0_0:1;
            uint64_t PTW:1;
            uint64_t S:1;
            uint64_t RES0_1:1;
            uint64_t RES1_2:1;
            uint64_t RES0_3:36;
            uint64_t IMP_DEF0:4;
            uint64_t IMP_DEF1:4;
            uint64_t IMP_DEF2:8;
        }__attribute__((packed)) S1;
    };
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegPAR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegPAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegPAR_EL1 copy()const volatile
    {
     RegPAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegPAR_EL1 copy()const
    {
     RegPAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegPAR_EL1: ";
        if(S0.F==0)
        {
            kout
                << "S0.F = " << S0.F << ", "
                << "S0.RES0_0 = " << S0.RES0_0 << ", "
                << "S0.SH = " << S0.SH << ", "
                << "S0.NS = " << S0.NS << ", "
                << "S0.IMP_DEF_1 = " << S0.IMP_DEF_1 << ", "
                << "S0.RES1_2 = " << S0.RES1_2 << ", "
                << "S0.PA47_12 = " << Hex(S0.PA47_12) << ", "
                << "S0.PA51_48 = " << Hex(S0.PA51_48) << ", "
                << "S0.RES0_3 = " << S0.RES0_3 << ", "
                << "S0.ATTR = " << S0.ATTR << ", "
                << "\n";
        }
        else
        {
            kout
                << "S1.F = " << S1.F << ", "
                << "S1.FST = " << S1.FST << ", "
                << "S1.RES0_0 = " << S1.RES0_0 << ", "
                << "S1.PTW = " << S1.PTW << ", "
                << "S1.S = " << S1.S << ", "
                << "S1.RES0_1 = " << S1.RES0_1 << ", "
                << "S1.RES1_2 = " << S1.RES1_2 << ", "
                << "S1.RES0_3 = " << S1.RES0_3 << ", "
                << "S1.IMP_DEF0 = " << S1.IMP_DEF0 << ", "
                << "S1.IMP_DEF1 = " << S1.IMP_DEF1 << ", "
                << "S1.IMP_DEF2 = " << S1.IMP_DEF2 << ", "
                << "\n";
        }
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegPAR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegPAR_EL1 make(uint64_t val)
    {
        RegPAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegPAR_EL1 read()
    {
        RegPAR_EL1 res;
        __asm__ __volatile__("mrs %0,PAR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegPAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,PAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr PAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t Attr0:8;
            uint64_t Attr1:8;
            uint64_t Attr2:8;
            uint64_t Attr3:8;
            uint64_t Attr4:8;
            uint64_t Attr5:8;
            uint64_t Attr6:8;
            uint64_t Attr7:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMAIR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMAIR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMAIR_EL1 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMAIR_EL1 copy()const volatile
    {
     RegMAIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL1 copy()const
    {
     RegMAIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMAIR_EL1: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMAIR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMAIR_EL1 make(uint64_t val)
    {
        RegMAIR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMAIR_EL1 read()
    {
        RegMAIR_EL1 res;
        __asm__ __volatile__("mrs %0,MAIR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MAIR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t Attr0:8;
            uint64_t Attr1:8;
            uint64_t Attr2:8;
            uint64_t Attr3:8;
            uint64_t Attr4:8;
            uint64_t Attr5:8;
            uint64_t Attr6:8;
            uint64_t Attr7:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMAIR_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMAIR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMAIR_EL2 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMAIR_EL2 copy()const volatile
    {
     RegMAIR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL2 copy()const
    {
     RegMAIR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMAIR_EL2: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMAIR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMAIR_EL2 make(uint64_t val)
    {
        RegMAIR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMAIR_EL2 read()
    {
        RegMAIR_EL2 res;
        __asm__ __volatile__("mrs %0,MAIR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MAIR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t Attr0:8;
            uint64_t Attr1:8;
            uint64_t Attr2:8;
            uint64_t Attr3:8;
            uint64_t Attr4:8;
            uint64_t Attr5:8;
            uint64_t Attr6:8;
            uint64_t Attr7:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMAIR_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMAIR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMAIR_EL3 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMAIR_EL3 copy()const volatile
    {
     RegMAIR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL3 copy()const
    {
     RegMAIR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMAIR_EL3: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMAIR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMAIR_EL3 make(uint64_t val)
    {
        RegMAIR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMAIR_EL3 read()
    {
        RegMAIR_EL3 res;
        __asm__ __volatile__("mrs %0,MAIR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MAIR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSCTLR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t M:1;
            uint32_t A:1;
            uint32_t C:1;
            uint32_t SA:1;
            uint32_t SA0:1;
            uint32_t CP15BEN:1;
            uint32_t RES0_0:1;
            uint32_t ITD:1;
            uint32_t SED:1;
            uint32_t UMA:1;
            uint32_t RES0_1:1;
            uint32_t RES1_2:1;
            uint32_t I:1;
            uint32_t RES0_3:1;
            uint32_t DZE:1;
            uint32_t UCT:1;
            uint32_t nTWI:1;
            uint32_t RES0_4:1;
            uint32_t nTWE:1;
            uint32_t WXN:1;
            uint32_t RES1_5:1;
            uint32_t IESB:1;
            uint32_t RES1_6:1;
            uint32_t SPAN:1;
            uint32_t E0E:1;
            uint32_t EE:1;
            uint32_t UCI:1;
            uint32_t RES0_7:1;
            uint32_t nTLSMD:1;
            uint32_t LSMAOE:1;
            uint32_t RES0_8:2;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSCTLR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSCTLR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSCTLR_EL1 & setMandatoryFields()
    {
        M = 0;
        A = 0;
        C = 0;
        SA = 0;
        SA0 = 0;
        CP15BEN = 0;
        RES0_0 = 0;
        ITD = 0;
        SED = 0;
        UMA = 0;
        RES0_1 = 0;
        RES1_2 = 1;
        I = 0;
        RES0_3 = 0;
        DZE = 0;
        UCT = 0;
        nTWI = 0;
        RES0_4 = 0;
        nTWE = 0;
        WXN = 0;
        RES1_5 = 1;
        IESB = 0;
        RES1_6 = 1;
        SPAN = 0;
        E0E = 0;
        EE = 0;
        UCI = 0;
        RES0_7 = 0;
        nTLSMD = 0;
        LSMAOE = 0;
        RES0_8 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSCTLR_EL1 copy()const volatile
    {
     RegSCTLR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSCTLR_EL1 copy()const
    {
     RegSCTLR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSCTLR_EL1: ";
            kout
                << "M = " << M << ", "
                << "A = " << A << ", "
                << "C = " << C << ", "
                << "SA = " << SA << ", "
                << "SA0 = " << SA0 << ", "
                << "CP15BEN = " << CP15BEN << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "ITD = " << ITD << ", "
                << "SED = " << SED << ", "
                << "UMA = " << UMA << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "RES1_2 = " << RES1_2 << ", "
                << "I = " << I << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "DZE = " << DZE << ", "
                << "UCT = " << UCT << ", "
                << "nTWI = " << nTWI << ", "
                << "RES0_4 = " << RES0_4 << ", "
                << "nTWE = " << nTWE << ", "
                << "WXN = " << WXN << ", "
                << "RES1_5 = " << RES1_5 << ", "
                << "IESB = " << IESB << ", "
                << "RES1_6 = " << RES1_6 << ", "
                << "SPAN = " << SPAN << ", "
                << "E0E = " << E0E << ", "
                << "EE = " << EE << ", "
                << "UCI = " << UCI << ", "
                << "RES0_7 = " << RES0_7 << ", "
                << "nTLSMD = " << nTLSMD << ", "
                << "LSMAOE = " << LSMAOE << ", "
                << "RES0_8 = " << RES0_8 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSCTLR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSCTLR_EL1 make(uint32_t val)
    {
        RegSCTLR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSCTLR_EL1 read()
    {
        RegSCTLR_EL1 res;
        __asm__ __volatile__("mrs %0,SCTLR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSCTLR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SCTLR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SCTLR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDLR_EL0
{
public:
    using ScaleType=uint64_t;
            uint64_t RestartAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegDLR_EL0& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegDLR_EL0 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegDLR_EL0 & setMandatoryFields()
    {
        RestartAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegDLR_EL0 copy()const volatile
    {
     RegDLR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegDLR_EL0 copy()const
    {
     RegDLR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegDLR_EL0: ";
            kout
                << "RestartAddr = " << RestartAddr << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegDLR_EL0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegDLR_EL0 make(uint64_t val)
    {
        RegDLR_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegDLR_EL0 read()
    {
        RegDLR_EL0 res;
        __asm__ __volatile__("mrs %0,DLR_EL0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegDLR_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,DLR_EL0\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr DLR_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDSPSR_EL0
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegDSPSR_EL0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegDSPSR_EL0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegDSPSR_EL0 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegDSPSR_EL0 copy()const volatile
    {
     RegDSPSR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegDSPSR_EL0 copy()const
    {
     RegDSPSR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegDSPSR_EL0: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegDSPSR_EL0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegDSPSR_EL0 make(uint32_t val)
    {
        RegDSPSR_EL0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegDSPSR_EL0 read()
    {
        RegDSPSR_EL0 res;
        __asm__ __volatile__("mrs %0,DSPSR_EL0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegDSPSR_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,DSPSR_EL0\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr DSPSR_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/ExceptionState.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/exception_def.h" 1
# 16 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/exception_def.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/asm_instructions.h" 1
# 132 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/asm_instructions.h"
__attribute__((always_inline)) inline void asm_nop();
__attribute__((always_inline)) inline void asm_isb();
__attribute__((always_inline)) inline void asm_eret();
__attribute__((always_inline)) inline RegPAR_EL1 asm_at(uint64_t va);
__attribute__((always_inline)) inline void asm_svc(uint16_t imm);
__attribute__((always_inline)) inline void asm_wfe();
__attribute__((always_inline)) inline __attribute__((noreturn)) void asm_wfe_loop();
__attribute__((always_inline)) inline void asm_tlbi_aside1(uint16_t asid);
__attribute__((always_inline)) inline void asm_tlbi_allel1();
__attribute__((always_inline)) inline void asm_tbli_vmallel1();



void asm_nop()
{
 __asm__ __volatile__("nop \n\t");
}
void asm_isb()
{
 __asm__ __volatile__("isb \n\t");
}
void asm_eret()
{
 __asm__ __volatile__("eret \n\t");
}
RegPAR_EL1 asm_at(uint64_t va)
{
 __asm__ __volatile__("at S1E1R,%0 \n\t"::"r"(va));
 return RegPAR_EL1::read();
}
void asm_svc(uint16_t imm)
{
 __asm__ __volatile__("svc %0"::"i"(imm));
}
void asm_wfe()
{
 __asm__ __volatile__("wfe \n\t");
}
void asm_wfe_loop()
{
 while(true)
  asm_wfe();
}


void asm_tlbi_aside1(uint16_t asid)
{
 __asm__ __volatile__(
   "tlbi aside1,%0 \n\t"
   ::"r"(static_cast<uint64_t>(asid)<<(64 - 16))
 );
}

void asm_tlbi_allel1()
{
 __asm__ __volatile__("tlbi ALLE1 \n\t");
}
void asm_tbli_vmallel1()
{
 __asm__ __volatile__("tlbi  VMALLE1 \n\t");
}
# 17 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/exception_def.h" 2
enum ExceptionClass{
 UNDEF_INST=0b000000,
 INSTR_ABORT_LOWER_EL = 0b100000,
 INSTR_ABORT_SAME_EL = 0b100001,
 PC_ALIGNMENT_FAULT = 0b100010,
 DATA_ABORT_LOWER_EL = 0b100100,
 DATA_ABORT_SAME_EL = 0b100101,
 SP_ALIGNMENT_FAULT = 0b100110,
 SERROR_INTERRUPT = 0b101111,
 SVC_AA64=0b010101,
 HVC_AA64 = 0b010110,
 SMC_AA64 = 0b010111,
};
# 43 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/exception_def.h"
enum ExceptionType:uint64_t{
 SYNC=0,
 IRQ=1,
 FIQ=2,
 SError=3
};
enum ExceptionOrigin:uint64_t{
 CUR_SP_EL0=0,
 CUR_SP_ELx=1,
 FROM_LOWER_A64=2,
 FROM_LOWER_A32=3,
};
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/ExceptionState.h" 2
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 1 3
# 32 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
       
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3

# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{

# 68 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }




      constexpr value_type operator()() const { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 103 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };
# 195 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 327 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 355 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 939 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;

  template<typename _Tp, typename... _Args>
    struct is_constructible;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>,
       __not_<is_constructible<__dst_t, _From>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1774 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<wchar_t> : __make_signed<unsigned int>
    { };



  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };
# 1893 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2039 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2078 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;


  template<typename...> using __void_t = void;
# 2507 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2551 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename remove_cv<
      typename remove_reference<_Tp>::type>::type>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };
# 2756 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Result, typename _Ret, typename = void>
    struct __is_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
    : is_convertible<typename _Result::type, _Ret>::type
    { };

  template<typename _Result>
    struct __is_invocable_impl<_Result, void, __void_t<typename _Result::type>>
    : true_type
    { };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 3112 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3

}
# 14 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/ExceptionState.h" 2


# 15 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/interrupt/ExceptionState.h"
class ExceptionState
{
public:
 static constexpr size_t GENERAL_REG_NUM=31;
 ExceptionState();
 ExceptionState(uint64_t * savedRegs,ExceptionType type,ExceptionOrigin origin);
 void restore();

 ExceptionType _type;
 ExceptionOrigin _origin;
 uint64_t *_generalRegisters;
 RegSPSR_EL1 _spsr;
 RegELR_EL1 _elr;
 RegESR_EL1 _esr;
 RegFAR_EL1 _far;
};
# 9 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/interrupt/ExceptionState.cpp" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic/error.h" 1
# 19 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic/error.h"
void __attribute__((noreturn)) reportError(const char *s);


void resume();

void __attribute__((noreturn)) report_assert_error(const char *file,size_t line,const char *func,const char *expr);
# 10 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/interrupt/ExceptionState.cpp" 2

ExceptionState::ExceptionState()
 :_type(static_cast<ExceptionType>(0)),
  _origin(static_cast<ExceptionOrigin>(0)),
 _generalRegisters(nullptr),
 _spsr(),
 _elr(),
 _esr(),
 _far()
{
 reportError("should never be called");
}

ExceptionState::ExceptionState(uint64_t * savedRegs,ExceptionType type,ExceptionOrigin origin)
 :_type(type),
  _origin(origin),
 _generalRegisters(savedRegs),
 _spsr(),
 _elr(),
 _esr(),
 _far()
{
 _spsr.update();
 _elr.update();
 _esr.update();
 _far.update();
}
void ExceptionState::restore()
{
 _spsr.write();
 _elr.write();
}
