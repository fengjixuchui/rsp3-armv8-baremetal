# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/memory/VirtualMap.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "./cxx_macros.h" 1
# 32 "<command-line>" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/memory/VirtualMap.cpp"






# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMap.h" 1
# 10 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMap.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryManager.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryManager.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h" 1







# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 1 3
# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 3
       
# 43 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 3






# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 1 3
# 229 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3

# 229 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 251 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 533 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/os_defines.h" 1 3
# 534 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 2 3


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/cpu_defines.h" 1 3
# 537 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/aarch64-elf/bits/c++config.h" 2 3
# 50 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 2 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 1 3 4
# 149 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 216 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 426 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 437 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 51 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstddef" 2 3


namespace std
{

  using ::max_align_t;
}
# 9 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h" 2
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 1 3
# 32 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 3
       
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 3
# 41 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint.h" 1 3 4
# 11 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint.h" 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint-gcc.h" 1 3 4
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint-gcc.h" 3 4
typedef signed char int8_t;


typedef short int int16_t;


typedef int int32_t;


typedef long int int64_t;


typedef unsigned char uint8_t;


typedef short unsigned int uint16_t;


typedef unsigned int uint32_t;


typedef long unsigned int uint64_t;




typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef short unsigned int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef long unsigned int uint_least64_t;



typedef int int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned int uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef long unsigned int uint_fast64_t;




typedef long int intptr_t;


typedef long unsigned int uintptr_t;




typedef long int intmax_t;
typedef long unsigned int uintmax_t;
# 12 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stdint.h" 2 3 4
# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 10 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h" 2
# 22 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h"

# 22 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/def.h"
extern const char EMPTY_STR[1];



constexpr int UNIT_K=1024;
constexpr int KiB = UNIT_K;
constexpr int MiB = UNIT_K * KiB;
constexpr int GiB = UNIT_K * MiB;
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryManager.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryChunk.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryChunk.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic_util.h" 1
# 17 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic_util.h"
extern const char digitsMap[];



size_t itob(size_t i,char *dst,size_t size);
size_t itod(size_t i,char *dst,size_t size);
size_t itox(size_t i,char *dst,size_t size);

size_t itos(size_t i,unsigned int base,char *dst,size_t size);


uint64_t alignAhead(uint64_t d,uint64_t alignment);
uint64_t alignBackward(uint64_t d,uint64_t alignment);





void reverse(char *str,size_t size);



const char *strOffset(const char *p,size_t offset);

namespace{

 template <size_t bit,size_t ... bits>
 struct BitMaskStruct{
  static constexpr size_t value= BitMaskStruct<bit>::value|BitMaskStruct<bits...>::value;
 };
 template <size_t bit>
 struct BitMaskStruct<bit>{
  static constexpr size_t value=(1u<<bit);
 };

}




template <uint8_t...bit>
__attribute__((always_inline)) inline size_t bitMask()
{
 return BitMaskStruct<bit...>::value;
}


template <size_t ... bit>
__attribute__((always_inline)) inline constexpr size_t bitOnes()
{
 return BitMaskStruct<bit...>::value;
}

template <size_t ...bit>
__attribute__((always_inline)) inline constexpr size_t bitZeros()
{
 return ~(BitMaskStruct<bit...>::value);
}

template <size_t ...bit,class T>
__attribute__((always_inline)) inline T bitsSet(T t)
{
 return t | bitOnes<bit...>();
}

template <size_t ...bit,class T>
__attribute__((always_inline)) inline T bitsClear(T t)
{
 return (t & bitZeros<bit...>());
}


template <size_t ...bit,class T>
__attribute__((always_inline)) inline T bitsKept(T t)
{
 return (t & bitOnes<bit...>());
}
template <size_t ...bit,class T>
__attribute__((always_inline)) inline bool bitsAnySet(T t)
{
 return bitsKept<bit...>(t);
}
template <size_t ...bit,class T>
__attribute__((always_inline)) inline bool bitsNonSet(T t)
{
 return !bitsAnySet<bit...>(t);
}



template <size_t ...bitsAsOne,class VoidT,size_t ...bitsAsZero>
__attribute__((always_inline)) inline size_t bitsMix0()
{
 return bitsClear<bitsAsZero...>(bitsSet<bitsAsOne...>(static_cast<size_t>(0)));
}

template <size_t ...bitsAsOne,class VoidT,size_t ...bitsAsZero>
__attribute__((always_inline)) inline size_t bitsMix1()
{
 return bitsClear<bitsAsZero...>(bitsSet<bitsAsOne...>(static_cast<size_t>(0xffffffffffffffffUL)));
}

__attribute__((always_inline)) inline uint64_t bitMask(uint8_t bit)
{
 return (1u << bit);
}
template <uint64_t i>
__attribute__((always_inline)) inline uint64_t upperMaskBits()
{
 return 0xffffffffffffffff >> (64-i) << (64-i);
}
template <uint64_t i>
__attribute__((always_inline)) inline uint64_t lowerMaskBits()
{
 return 0xffffffffffffffff << (64-i) >> (64-i);
}

__attribute__((always_inline)) inline uint64_t upperMaskBits(uint64_t i)
{
 return 0xffffffffffffffff >> (64-i) << (64-i);
}

__attribute__((always_inline)) inline uint64_t lowerMaskBits(uint64_t i)
{
 return 0xffffffffffffffff << (64-i) >> (64-i);
}
__attribute__((always_inline)) inline uint64_t middleMaskBits(uint64_t lowerBound,uint64_t upperBound)
{

 return 0xffffffffffffffff >> lowerBound << (64 - upperBound - 1 + lowerBound) >> (64-upperBound -1);
}


template <class Type,class ValueType>
__attribute__((always_inline)) inline void setBits(Type & i, uint8_t lowerBound,uint8_t upperBound,ValueType v)
{

 i = (i & (~middleMaskBits(lowerBound, upperBound))) |((v & lowerMaskBits(upperBound - lowerBound + 1))<<lowerBound );
}
__attribute__((always_inline)) inline uint64_t getBits(uint64_t i, uint8_t lowerBound,uint8_t upperBound)
{
 return (i>>lowerBound)&lowerMaskBits(upperBound - lowerBound + 1);
}
# 175 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic_util.h"
template <class Type,class ValueType>
__attribute__((always_inline)) inline void setBit(Type & i,uint8_t index,ValueType v)
{
 setBits(i,index,index,v);
}
__attribute__((always_inline)) inline uint64_t getBit(uint64_t i,uint8_t index)
{
 return getBits(i,index,index);
}
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryChunk.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/OffsetChunk.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/OffsetChunk.h"
class OffsetChunk{
public:
 enum { OFFSET_BITS = 7, END_BITS=1, };
 enum {MAX_OFFSET = (1ul<<OFFSET_BITS), };
 __attribute__((always_inline)) inline OffsetChunk(uint8_t chunkOffset,bool end)
  :_chunkOffset(chunkOffset),
   _end(end)
 {}
 __attribute__((always_inline)) inline bool validChunk()const { return (!_end && _chunkOffset==0);}
 __attribute__((always_inline)) inline bool endChunk()const { return _end;}
 __attribute__((always_inline)) inline bool offsetChunk()const { return (!_end && _chunkOffset!=0);}
 __attribute__((always_inline)) inline uint8_t chunkOffset() const {return _chunkOffset;}
 __attribute__((always_inline)) inline void chunkOffset(uint8_t chunkOffset){_chunkOffset = chunkOffset;}
 __attribute__((always_inline)) inline void end(bool end){ _end = end; }
private:
 uint8_t _chunkOffset:OFFSET_BITS;
 uint8_t _end :END_BITS;

}__attribute__((packed));


static_assert(sizeof(OffsetChunk)==1,"error OffsetChunk size!=1");
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryChunk.h" 2
# 29 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryChunk.h"
class MemoryChunk
 :public OffsetChunk
{
public:



 enum {ALLOCATE_BITS=1,SIZE_BITS=55};
 enum {MAX_SIZE = ( 1ul << SIZE_BITS)};
 MemoryChunk(size_t chunkOffset,bool end,bool allocated,size_t size);
 __attribute__((always_inline)) inline bool allocated()const { return _allocated;}
 __attribute__((always_inline)) inline void allocated(bool alloced) { _allocated=alloced;}
 __attribute__((always_inline)) inline size_t size()const{return _size;}
 __attribute__((always_inline)) inline void size(size_t s){_size=s;}
 const MemoryChunk* nextContineous()const;
 MemoryChunk* nextContineous();
 const MemoryChunk* nextValid()const;
 MemoryChunk* nextValid();
 void* dataPtr();
 const void * dataPtr()const;
 void* endPtr();
 const void * endPtr()const;

 MemoryChunk* findAllocable(size_t n,size_t alignment,size_t &moveOffset);







 MemoryChunk* moveAhead(size_t moveSize);

 size_t moveOffsetOfAllocSuchAlignedSpace(size_t allocSize,size_t alignment)const;







 bool split(size_t splitSize);



 void mergeTrailingsUnallocated();

 static MemoryChunk * chunkPtrOfDataPtr(void *dataPtr);
 static const MemoryChunk * chunkPtrOfDataPtr(const void *dataPtr);
private:

 size_t _allocated :ALLOCATE_BITS;
 size_t _size :SIZE_BITS;

}__attribute__((packed));

static_assert(sizeof(MemoryChunk)==sizeof(size_t), "error MemoryChunk");
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryManager.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/runtime_def.h" 1
# 14 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryManager.h" 2
# 26 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryManager.h"
class MemoryManager{
public:
 enum { CHUNK_SIZE = sizeof(MemoryChunk), MINIMAL_ALLOC_SIZE = sizeof(size_t), MINIMAL_ALIGNMENT = sizeof(size_t) };
 MemoryManager()=delete;



 MemoryManager(void *base,size_t size,bool initChunks=true);
 __attribute__((always_inline)) inline void rebase(size_t diff) { _base += diff;*reinterpret_cast<char**>(&_headChunk)+=diff;}
public:

 size_t normalizeAllocSize(size_t n);


 void* allocate(size_t n);


 void* allocate(size_t n,size_t alignment);
 template <class T>
 T allocateAs(size_t n);
 template <class T>
 T allocateAs(size_t n,size_t alignment);
# 57 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryManager.h"
 bool tryIncrease(void *origin,size_t incSize);
 bool tryDecrease(void *origin,size_t decSize);
# 67 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryManager.h"
 void* reallocate(void *origin,size_t newSize,size_t oldSize = 0xffffffffffffffffUL);

 template <class T>
 T reallocateAs(void *origin,size_t newSize,size_t oldSize = 0xffffffffffffffffUL);





 void deallocate(void *p);





 size_t getAllocatedLength(void *origin)const;

 __attribute__((always_inline)) inline const char* base() const {return _base;}
 __attribute__((always_inline)) inline const size_t size() const {return _size;}

private:
 MemoryChunk *_headChunk;
 char *_base;
 size_t _size;
};



extern MemoryManager mman;



struct MemAbort{};


extern MemAbort m_abort;


void *operator new(size_t size,MemAbort);
void *operator new[](size_t size,MemAbort);



# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/MemoryManager.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/MemoryManager.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryManager.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/MemoryManager.h" 2


template <class T>
T MemoryManager::allocateAs(size_t n)
{
 return reinterpret_cast<T>(this->allocate(n));
}
template <class T>
T MemoryManager::allocateAs(size_t n,size_t alignment)
{
 return reinterpret_cast<T>(this->allocate(n,alignment));
}

template <class T>
T MemoryManager::reallocateAs(void *origin,size_t newSize,size_t oldSize)
{
 return reinterpret_cast<T>(reallocate(origin, newSize,oldSize));
}
# 111 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/MemoryManager.h" 2
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMap.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/vmsa_descriptors.h" 1






# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h" 1
# 14 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h"
size_t printk(char ch);


size_t printk(const char *s);

size_t printk(const char *s,size_t n);


void flush();




# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/printk.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/printk.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/printk.h" 2
# 28 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/printk.h" 2
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/Output.h" 2


class Output{
public:
 size_t print(const char *s,size_t len);
 size_t print(const char *s);
 Output & operator<<(char ch);

 Output & operator<<(uint8_t u);
 Output & operator<<(uint16_t u);
 Output & operator<<(uint32_t u);
 Output & operator<<(bool i);
 Output & operator<<(short i);
 Output & operator<<(int i);
 Output & operator<<(double d);
 Output & operator<<(const char *s);
 Output & operator<<(size_t i);
 Output & operator<<(const void *p);
 Output & operator<<(const volatile void *p);
 Output & flush();
};



extern Output kout;


constexpr size_t koutBufSize = 65;
extern char koutBuf[koutBufSize];
# 8 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/vmsa_descriptors.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h" 1
# 15 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h"
template <int Base>
class IntegerFormatter{
public:
 IntegerFormatter(size_t num);
 IntegerFormatter(const void *p);
 char *format()const;
private:
 size_t num;
};


using Hex=IntegerFormatter<16>;
using Dec=IntegerFormatter<10>;
using Bin=IntegerFormatter<2>;

template <int Base>
Output & operator<<(Output & out,const IntegerFormatter<Base> &hf);



# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/IntegerFormatter.h" 2



template <int Base>
IntegerFormatter<Base>::IntegerFormatter(size_t num)
 :num(num){}

template <int Base>
IntegerFormatter<Base>::IntegerFormatter(const void *p)
 :num(reinterpret_cast<size_t>(p)){}

template <int Base>
char *IntegerFormatter<Base>::format()const
{
 itos(num, Base, koutBuf, koutBufSize);
 return koutBuf;
}

template <int Base>
Output & operator<<(Output &out,const IntegerFormatter<Base> &hf)
{
 out << hf.format();
 return out;
}
# 36 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/io/IntegerFormatter.h" 2
# 9 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/vmsa_descriptors.h" 2

class Descriptor4KBL0
{
public:
    using ScaleType=uint64_t;
            uint64_t Valid:1;
            uint64_t IsTable:1;
            uint64_t ignored_0:10;
            uint64_t NextLevelTableAddr:36;
            uint64_t RES0_1:4;
            uint64_t ignored_2:7;
            uint64_t PXNTable:1;
            uint64_t XNTable:1;
            uint64_t APTable:2;
            uint64_t NSTable:1;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline Descriptor4KBL0& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile Descriptor4KBL0 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline Descriptor4KBL0 & setMandatoryFields()
    {
        Valid = 0;
        IsTable = 0;
        ignored_0 = 0;
        NextLevelTableAddr = 0;
        RES0_1 = 0;
        ignored_2 = 0;
        PXNTable = 0;
        XNTable = 0;
        APTable = 0;
        NSTable = 0;
        return *this;
        }
    __attribute__((always_inline)) inline Descriptor4KBL0 copy()const volatile
    {
     Descriptor4KBL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline Descriptor4KBL0 copy()const
    {
     Descriptor4KBL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "Descriptor4KBL0: ";
            kout
                << "Valid = " << Valid << ", "
                << "IsTable = " << IsTable << ", "
                << "ignored_0 = " << ignored_0 << ", "
                << "NextLevelTableAddr = " << Hex(NextLevelTableAddr) << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "ignored_2 = " << ignored_2 << ", "
                << "PXNTable = " << PXNTable << ", "
                << "XNTable = " << XNTable << ", "
                << "APTable = " << APTable << ", "
                << "NSTable = " << NSTable << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const Descriptor4KBL0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL0& make(void *addr,uint64_t val)
    {
        return reinterpret_cast<Descriptor4KBL0*>(addr)->set(val);
    }
    __attribute__((always_inline)) inline static volatile Descriptor4KBL0& make(volatile void *addr,uint64_t val)
    {
        return reinterpret_cast<volatile Descriptor4KBL0*>(addr)->set(val);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL0& of(size_t addr)
    {
        return *reinterpret_cast<Descriptor4KBL0*>(addr);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL0& of(void* addr)
    {
        return *reinterpret_cast<Descriptor4KBL0*>(addr);
    }
    __attribute__((always_inline)) inline static volatile Descriptor4KBL0& of(volatile void* addr)
    {
        return *reinterpret_cast<volatile Descriptor4KBL0*>(addr);
    }
}__attribute__((packed));


class Descriptor4KBL1
{
public:
    using ScaleType=uint64_t;
    union {
        struct {
            uint64_t Valid:1;
            uint64_t IsTable:1;
            uint64_t AttrIndex:3;
            uint64_t NS:1;
            uint64_t AP:2;
            uint64_t SH:2;
            uint64_t AF:1;
            uint64_t nG:1;
            uint64_t RES0_0:18;
            uint64_t OutputAddr:18;
            uint64_t RES0_1:4;
            uint64_t Contiguous:1;
            uint64_t PXN:1;
            uint64_t UXN:1;
            uint64_t reserved_2:4;
            uint64_t PBHA:4;
            uint64_t ignored_3:1;
        }__attribute__((packed)) S0;
        struct {
            uint64_t Valid:1;
            uint64_t IsTable:1;
            uint64_t ignored_0:10;
            uint64_t NextLevelTableAddr:36;
            uint64_t RES0_1:4;
            uint64_t ignored_2:7;
            uint64_t PXNTable:1;
            uint64_t XNTable:1;
            uint64_t APTable:2;
            uint64_t NSTable:1;
        }__attribute__((packed)) S1;
    };
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline Descriptor4KBL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile Descriptor4KBL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline Descriptor4KBL1 copy()const volatile
    {
     Descriptor4KBL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline Descriptor4KBL1 copy()const
    {
     Descriptor4KBL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "Descriptor4KBL1: ";
        if(S0.IsTable==0)
        {
            kout
                << "S0.Valid = " << S0.Valid << ", "
                << "S0.IsTable = " << S0.IsTable << ", "
                << "S0.AttrIndex = " << S0.AttrIndex << ", "
                << "S0.NS = " << S0.NS << ", "
                << "S0.AP = " << S0.AP << ", "
                << "S0.SH = " << S0.SH << ", "
                << "S0.AF = " << S0.AF << ", "
                << "S0.nG = " << S0.nG << ", "
                << "S0.RES0_0 = " << S0.RES0_0 << ", "
                << "S0.OutputAddr = " << Hex(S0.OutputAddr) << ", "
                << "S0.RES0_1 = " << S0.RES0_1 << ", "
                << "S0.Contiguous = " << S0.Contiguous << ", "
                << "S0.PXN = " << S0.PXN << ", "
                << "S0.UXN = " << S0.UXN << ", "
                << "S0.reserved_2 = " << S0.reserved_2 << ", "
                << "S0.PBHA = " << S0.PBHA << ", "
                << "S0.ignored_3 = " << S0.ignored_3 << ", "
                << "\n";
        }
        else
        {
            kout
                << "S1.Valid = " << S1.Valid << ", "
                << "S1.IsTable = " << S1.IsTable << ", "
                << "S1.ignored_0 = " << S1.ignored_0 << ", "
                << "S1.NextLevelTableAddr = " << Hex(S1.NextLevelTableAddr) << ", "
                << "S1.RES0_1 = " << S1.RES0_1 << ", "
                << "S1.ignored_2 = " << S1.ignored_2 << ", "
                << "S1.PXNTable = " << S1.PXNTable << ", "
                << "S1.XNTable = " << S1.XNTable << ", "
                << "S1.APTable = " << S1.APTable << ", "
                << "S1.NSTable = " << S1.NSTable << ", "
                << "\n";
        }
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const Descriptor4KBL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL1& make(void *addr,uint64_t val)
    {
        return reinterpret_cast<Descriptor4KBL1*>(addr)->set(val);
    }
    __attribute__((always_inline)) inline static volatile Descriptor4KBL1& make(volatile void *addr,uint64_t val)
    {
        return reinterpret_cast<volatile Descriptor4KBL1*>(addr)->set(val);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL1& of(size_t addr)
    {
        return *reinterpret_cast<Descriptor4KBL1*>(addr);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL1& of(void* addr)
    {
        return *reinterpret_cast<Descriptor4KBL1*>(addr);
    }
    __attribute__((always_inline)) inline static volatile Descriptor4KBL1& of(volatile void* addr)
    {
        return *reinterpret_cast<volatile Descriptor4KBL1*>(addr);
    }
}__attribute__((packed));


class Descriptor4KBL2
{
public:
    using ScaleType=uint64_t;
    union {
        struct {
            uint64_t Valid:1;
            uint64_t IsTable:1;
            uint64_t NS:1;
            uint64_t AP:2;
            uint64_t SH:2;
            uint64_t AF:1;
            uint64_t nG:1;
            uint64_t RES0_0:9;
            uint64_t OutputAddr:27;
            uint64_t RES0_1:4;
            uint64_t Contiguous:1;
            uint64_t PXN:1;
            uint64_t UXN:1;
            uint64_t reserved_2:4;
            uint64_t PBHA:4;
            uint64_t ignored_3:1;
        }__attribute__((packed)) S0;
        struct {
            uint64_t Valid:1;
            uint64_t IsTable:1;
            uint64_t ignored_0:10;
            uint64_t NextLevelTableAddr:36;
            uint64_t RES0_1:4;
            uint64_t ignored_2:7;
            uint64_t PXNTable:1;
            uint64_t XNTable:1;
            uint64_t APTable:2;
            uint64_t NSTable:1;
        }__attribute__((packed)) S1;
    };
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline Descriptor4KBL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile Descriptor4KBL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline Descriptor4KBL2 copy()const volatile
    {
     Descriptor4KBL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline Descriptor4KBL2 copy()const
    {
     Descriptor4KBL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "Descriptor4KBL2: ";
        if(S0.IsTable==0)
        {
            kout
                << "S0.Valid = " << S0.Valid << ", "
                << "S0.IsTable = " << S0.IsTable << ", "
                << "S0.NS = " << S0.NS << ", "
                << "S0.AP = " << S0.AP << ", "
                << "S0.SH = " << S0.SH << ", "
                << "S0.AF = " << S0.AF << ", "
                << "S0.nG = " << S0.nG << ", "
                << "S0.RES0_0 = " << S0.RES0_0 << ", "
                << "S0.OutputAddr = " << Hex(S0.OutputAddr) << ", "
                << "S0.RES0_1 = " << S0.RES0_1 << ", "
                << "S0.Contiguous = " << S0.Contiguous << ", "
                << "S0.PXN = " << S0.PXN << ", "
                << "S0.UXN = " << S0.UXN << ", "
                << "S0.reserved_2 = " << S0.reserved_2 << ", "
                << "S0.PBHA = " << S0.PBHA << ", "
                << "S0.ignored_3 = " << S0.ignored_3 << ", "
                << "\n";
        }
        else
        {
            kout
                << "S1.Valid = " << S1.Valid << ", "
                << "S1.IsTable = " << S1.IsTable << ", "
                << "S1.ignored_0 = " << S1.ignored_0 << ", "
                << "S1.NextLevelTableAddr = " << Hex(S1.NextLevelTableAddr) << ", "
                << "S1.RES0_1 = " << S1.RES0_1 << ", "
                << "S1.ignored_2 = " << S1.ignored_2 << ", "
                << "S1.PXNTable = " << S1.PXNTable << ", "
                << "S1.XNTable = " << S1.XNTable << ", "
                << "S1.APTable = " << S1.APTable << ", "
                << "S1.NSTable = " << S1.NSTable << ", "
                << "\n";
        }
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const Descriptor4KBL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL2& make(void *addr,uint64_t val)
    {
        return reinterpret_cast<Descriptor4KBL2*>(addr)->set(val);
    }
    __attribute__((always_inline)) inline static volatile Descriptor4KBL2& make(volatile void *addr,uint64_t val)
    {
        return reinterpret_cast<volatile Descriptor4KBL2*>(addr)->set(val);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL2& of(size_t addr)
    {
        return *reinterpret_cast<Descriptor4KBL2*>(addr);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL2& of(void* addr)
    {
        return *reinterpret_cast<Descriptor4KBL2*>(addr);
    }
    __attribute__((always_inline)) inline static volatile Descriptor4KBL2& of(volatile void* addr)
    {
        return *reinterpret_cast<volatile Descriptor4KBL2*>(addr);
    }
}__attribute__((packed));


class Descriptor4KBL3
{
public:
    using ScaleType=uint64_t;
            uint64_t Valid:1;
            uint64_t RES1_0:1;
            uint64_t AttrIndex:3;
            uint64_t NS:1;
            uint64_t AP:2;
            uint64_t SH:2;
            uint64_t AF:1;
            uint64_t nG:1;
            uint64_t OutputAddr:36;
            uint64_t RES0_1:3;
            uint64_t DBM:1;
            uint64_t Contiguous:1;
            uint64_t PXN:1;
            uint64_t UXN:1;
            uint64_t reserved_2:4;
            uint64_t PBHA:4;
            uint64_t Ignored:1;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline Descriptor4KBL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile Descriptor4KBL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline Descriptor4KBL3 & setMandatoryFields()
    {
        Valid = 0;
        RES1_0 = 1;
        AttrIndex = 0;
        NS = 0;
        AP = 0;
        SH = 0;
        AF = 0;
        nG = 0;
        OutputAddr = 0;
        RES0_1 = 0;
        DBM = 0;
        Contiguous = 0;
        PXN = 0;
        UXN = 0;
        reserved_2 = 0;
        PBHA = 0;
        Ignored = 0;
        return *this;
        }
    __attribute__((always_inline)) inline Descriptor4KBL3 copy()const volatile
    {
     Descriptor4KBL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline Descriptor4KBL3 copy()const
    {
     Descriptor4KBL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "Descriptor4KBL3: ";
            kout
                << "Valid = " << Valid << ", "
                << "RES1_0 = " << RES1_0 << ", "
                << "AttrIndex = " << AttrIndex << ", "
                << "NS = " << NS << ", "
                << "AP = " << AP << ", "
                << "SH = " << SH << ", "
                << "AF = " << AF << ", "
                << "nG = " << nG << ", "
                << "OutputAddr = " << Hex(OutputAddr) << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "DBM = " << DBM << ", "
                << "Contiguous = " << Contiguous << ", "
                << "PXN = " << PXN << ", "
                << "UXN = " << UXN << ", "
                << "reserved_2 = " << reserved_2 << ", "
                << "PBHA = " << PBHA << ", "
                << "Ignored = " << Ignored << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const Descriptor4KBL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL3& make(void *addr,uint64_t val)
    {
        return reinterpret_cast<Descriptor4KBL3*>(addr)->set(val);
    }
    __attribute__((always_inline)) inline static volatile Descriptor4KBL3& make(volatile void *addr,uint64_t val)
    {
        return reinterpret_cast<volatile Descriptor4KBL3*>(addr)->set(val);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL3& of(size_t addr)
    {
        return *reinterpret_cast<Descriptor4KBL3*>(addr);
    }
    __attribute__((always_inline)) inline static Descriptor4KBL3& of(void* addr)
    {
        return *reinterpret_cast<Descriptor4KBL3*>(addr);
    }
    __attribute__((always_inline)) inline static volatile Descriptor4KBL3& of(volatile void* addr)
    {
        return *reinterpret_cast<volatile Descriptor4KBL3*>(addr);
    }
}__attribute__((packed));
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMap.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/programming/define_members.h" 1
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMap.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualAddress.h" 1
# 16 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualAddress.h"
class VirtualAddress{
public:
 struct SegmentedAddress{
   uint64_t offset:12;
   uint64_t index0:9;
   uint64_t index1:9;
   uint64_t index2:9;
   uint64_t index3:9;
   uint64_t upperBits:16;
 };
public:
 VirtualAddress(uint8_t addrLen=48);
 VirtualAddress(uint64_t vaddr,uint8_t addrLen=48);


 VirtualAddress& index(uint8_t which,uint32_t val);


 uint32_t index(uint8_t which)const;


 VirtualAddress& offset(uint64_t off);
 uint64_t offset()const;

 VirtualAddress& addrLen(uint8_t len);
 uint8_t addrLen()const;

 VirtualAddress& addr(uint64_t addr);
 uint64_t addr()const;


 VirtualAddress & ttbrSel(int i);
 int ttbrSel()const;

 bool valid()const;
 uint8_t initialLevel()const;
 bool hasLevel(uint8_t which)const;


private:
 uint8_t rightShiftBits(uint8_t which)const;
 uint8_t minimalLevelLength(uint8_t which)const;

 uint64_t levelIndexMask()const;



private:
 union{
  uint64_t _addr;
  SegmentedAddress _segAddr;
 };
 uint8_t _addrLen;
 bool _hasTag;

};
# 14 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMap.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/AddressSpaceDescriptor.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/AddressSpaceDescriptor.h"
class AddressSpaceDescriptor{
public:

 enum {
    F_TYPE=0,
    F_TYPE_END=3,
    F_READ_ONLY,
    F_CACHEABLE,
    F_EL0_ACCESS
 };

 enum Type{ T_NORMAL,T_PERIPHERAL,T_UNKOWN,T_NOT_VALID};
 AddressSpaceDescriptor();
 AddressSpaceDescriptor(void *addr,size_t size, Type type=T_NORMAL,bool readOnly=false,bool cacheable=true,bool el0Access=false);
 __attribute__((always_inline)) inline bool readOnly()const{ return _flags & (1<<F_READ_ONLY);}
 __attribute__((always_inline)) inline bool cacheable()const{ return _flags & (1<<F_CACHEABLE);}
 __attribute__((always_inline)) inline Type type()const { return static_cast<Type>(getBits(_flags, F_TYPE, F_TYPE_END));}
 __attribute__((always_inline)) inline bool el0Accessiable()const { return _flags & (1<<F_EL0_ACCESS);}
 __attribute__((always_inline)) inline void readOnly(bool v){ setBit(_flags,F_READ_ONLY,v);}
 __attribute__((always_inline)) inline void cacheable(bool v){ setBit(_flags ,F_CACHEABLE,v);}
 __attribute__((always_inline)) inline void type(Type t) { setBits(_flags, F_TYPE, F_TYPE_END,t);}
 __attribute__((always_inline)) inline void el0Accessiable(bool v) { setBit(_flags ,F_EL0_ACCESS,v);;}
 __attribute__((always_inline)) inline void* addr() const {return _addr;}
 __attribute__((always_inline)) inline void addr(void* addr) { _addr = addr;}
 __attribute__((always_inline)) inline size_t size() const { return _size;}
 __attribute__((always_inline)) inline void size(size_t size) { _size = size;}
private:
 uint8_t _flags;
 void * _addr;
 size_t _size;
};
# 15 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMap.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h" 1
# 22 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic/error.h" 1
# 19 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/generic/error.h"
void __attribute__((noreturn)) reportError(const char *s);


void resume();

void __attribute__((noreturn)) report_assert_error(const char *file,size_t line,const char *func,const char *expr);
# 23 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h" 2
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/initializer_list" 1 3
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/initializer_list" 3
       
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/initializer_list" 3





#pragma GCC visibility push(default)




# 43 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/initializer_list" 3
namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 24 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h" 2

# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 1 3
# 58 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3
       
# 59 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3
# 69 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 1 3
# 67 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
 
# 85 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

 
  }

}
# 70 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 2 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 1 3
# 59 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 1 3
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/concept_check.h" 1 3
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/concept_check.h" 3
       
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/concept_check.h" 3
# 35 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }


}


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 1 3
# 32 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
       
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{

# 68 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }




      constexpr value_type operator()() const { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 103 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };
# 195 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 327 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 355 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes...) const volatile && >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile & >
    : public true_type { };

  template<typename _Res, typename... _ArgTypes >
    struct is_function<_Res(_ArgTypes......) const volatile && >
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args...) >
    : public true_type
    { };

  template<typename _Res, typename... _Args >
    struct __is_referenceable<_Res(_Args......) >
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 939 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;

  template<typename _Tp, typename... _Args>
    struct is_constructible;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>,
       __not_<is_constructible<__dst_t, _From>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1774 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<wchar_t> : __make_signed<unsigned int>
    { };



  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };
# 1893 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2039 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2078 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;


  template<typename...> using __void_t = void;
# 2507 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2551 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename remove_cv<
      typename remove_reference<_Tp>::type>::type>::type
    { };

  template<typename _Tp>
    inline
    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };
# 2756 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3
  template<typename _Result, typename _Ret, typename = void>
    struct __is_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret, __void_t<typename _Result::type>>
    : is_convertible<typename _Result::type, _Ret>::type
    { };

  template<typename _Result>
    struct __is_invocable_impl<_Result, void, __void_t<typename _Result::type>>
    : true_type
    { };

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

  struct __nonesuch {
    __nonesuch() = delete;
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
# 3112 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/type_traits" 3

}
# 55 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 115 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 135 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
# 166 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 181 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };




  struct __nonesuch_no_braces : std::__nonesuch {
    explicit __nonesuch_no_braces(const __nonesuch&) = delete;
  };
# 197 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 241 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;

      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 269 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __not_<__and_<is_copy_assignable<_T1>,
                is_copy_assignable<_T2>>>::value,
  const pair&, const __nonesuch_no_braces&>::type __p) = delete;

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch_no_braces&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
    is_assignable<_T2&, const _U2&>>::value,
    pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
      typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
    is_assignable<_T2&, _U2&&>>::value,
    pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };






  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline





    void

    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 516 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 535 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/stl_pair.h" 3

}
# 71 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 2 3
# 82 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp, typename = void>
    struct __tuple_size_cv_impl { };

  template<typename _Tp>
    struct __tuple_size_cv_impl<_Tp, __void_t<decltype(tuple_size<_Tp>::value)>>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };



  template<typename _Tp>
    struct tuple_size<const _Tp> : __tuple_size_cv_impl<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp> : __tuple_size_cv_impl<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp> : __tuple_size_cv_impl<_Tp> { };
# 132 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3
  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };




  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes> struct _Index_tuple { };


  template<typename _Itup1, typename _Itup2> struct _Itup_cat;

  template<size_t... _Ind1, size_t... _Ind2>
    struct _Itup_cat<_Index_tuple<_Ind1...>, _Index_tuple<_Ind2...>>
    {
      using __type = _Index_tuple<_Ind1..., (_Ind2 + sizeof...(_Ind1))...>;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    : _Itup_cat<typename _Build_index_tuple<_Num / 2>::__type,
  typename _Build_index_tuple<_Num - _Num / 2>::__type>
    { };

  template<>
    struct _Build_index_tuple<1>
    {
      typedef _Index_tuple<0> __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num, size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
       "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;


  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 406 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/utility" 3

}
# 26 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h" 2

# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/new" 1 3
# 37 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/new" 3
       
# 38 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/new" 3


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/exception" 1 3
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/exception" 3
       
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/exception" 3

#pragma GCC visibility push(default)


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception.h" 1 3
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception.h" 3
       
# 35 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/exception" 2 3

extern "C++" {

namespace std
{


  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 101 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));
# 110 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/exception" 3
}

namespace __gnu_cxx
{

# 132 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception_ptr.h" 1 3
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception_defines.h" 1 3
# 38 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception_ptr.h" 2 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/cxxabi_init_exception.h" 1 3
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/cxxabi_init_exception.h" 3
       
# 35 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 1 3 4
# 39 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/cxxabi_init_exception.h" 2 3
# 50 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception_ptr.h" 2 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/typeinfo" 1 3
# 32 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/typeinfo" 3
       
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/typeinfo" 3



# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/hash_bytes.h" 1 3
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/hash_bytes.h" 3
       
# 34 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception_ptr.h" 2 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/new" 1 3
# 41 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 117 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 144 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }

  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {
# 200 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/exception_ptr.h" 3
      return exception_ptr();

    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 143 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/exception" 2 3
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/nested_exception.h" 1 3
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 42 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }


  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 144 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/exception" 2 3
# 41 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 120 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 168 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/new" 3
inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 216 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/new" 3
#pragma GCC visibility pop
# 28 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h" 2


# 29 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h"
template <class T>
class Vector{
public:
 enum { MINIMAL_CAPACITY = 8};

 using ValueType = T;
 using SizeType = size_t;
 Vector();
 Vector(size_t initSize,bool setMinCapacity=true);
 Vector(const std::initializer_list<T> &il);
 Vector<T> & operator=(const std::initializer_list<T> &il)=delete;
 Vector(const T *data,size_t n);
 Vector(const Vector<T> & vec);
 Vector<T> & operator=(const Vector<T> & vec);
 Vector(Vector<T> && vec);
 Vector<T>& operator=(Vector<T> && vec);
 ~Vector();
 __attribute__((always_inline)) inline void rebase(size_t diff) { if(_data){_data=reinterpret_cast<T*>(reinterpret_cast<char*>(_data)+diff);}}






 template <class CastType>
 Vector<CastType> && castMove();

 __attribute__((always_inline)) inline const T& operator[](size_t i)const { ((i<_size) ? (void)0 : report_assert_error("/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h", 56, __PRETTY_FUNCTION__, "i<_size"));return _data[i];}
 __attribute__((always_inline)) inline T &operator[](size_t i){((i<_size) ? (void)0 : report_assert_error("/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h", 57, __PRETTY_FUNCTION__, "i<_size"));return _data[i];}
 __attribute__((always_inline)) inline const T &first()const { ((_size>0) ? (void)0 : report_assert_error("/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h", 58, __PRETTY_FUNCTION__, "_size>0"));return _data[0];}
 __attribute__((always_inline)) inline T &first(){ ((_size>0) ? (void)0 : report_assert_error("/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h", 59, __PRETTY_FUNCTION__, "_size>0"));return _data[0];}
 __attribute__((always_inline)) inline const T &last()const { ((_size>0) ? (void)0 : report_assert_error("/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h", 60, __PRETTY_FUNCTION__, "_size>0"));return _data[_size-1];}
 __attribute__((always_inline)) inline T &last(){ ((_size>0) ? (void)0 : report_assert_error("/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h", 61, __PRETTY_FUNCTION__, "_size>0"));return _data[_size-1];}




 T popBack();
 void pushBack(T t);
 template <class ... Args>
 void emplaceBack(Args && ... args);
 __attribute__((always_inline)) inline T *data(){return _data;}
 __attribute__((always_inline)) inline const T* data()const{ return _data;}
 __attribute__((always_inline)) inline size_t size()const{return _size;}
 __attribute__((always_inline)) inline size_t capacity()const{return _capacity;}
 __attribute__((always_inline)) inline bool empty()const{return _size==0;}
 void clear();
 void erase(size_t i);
 Vector<T>& append(const Vector<T> &vec,size_t len=0xffffffffffffffffUL);




 size_t insert(size_t i,const T & t);




 bool resize(size_t newSize);
 bool ensureEnoughCapacity(size_t capacity);

 __attribute__((always_inline)) inline MemoryManager& memMan(){return mman;}

private:
 bool resizeCapacity(size_t capacity);
 bool adjustCapacityForOneMore();

 bool adjustCapacityForOneLess();

 __attribute__((always_inline)) inline static size_t getIncrementalSize(size_t curSize){return (curSize==0?MINIMAL_CAPACITY:(curSize * 3 / 2));}
private:
 T *_data;
 size_t _capacity;
 size_t _size;
};


template <class T>
Output & operator<<(Output &out,const Vector<T> & vec);


# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/data_structures/Vector.h" 1
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/data_structures/Vector.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/data_structures/Vector.h" 2

template <class T>
Vector<T>::Vector()
 :
 _data(nullptr),
 _capacity(0),
 _size(0)
{}

template <class T>
Vector<T>::Vector(size_t initSize,bool setMinCapacity)
 :
_data(nullptr),_capacity(0),_size(0)
 {
 if(setMinCapacity)
  _capacity=(initSize <= MINIMAL_CAPACITY ? MINIMAL_CAPACITY : initSize);
 else
  _capacity=initSize;
 if(_capacity>0)
 {
  _data = mman.allocateAs<T*>(_capacity*sizeof(T));
  if(_data)
  {
   for(size_t i=0;i!=initSize;++i)
    new (_data+i) T();
   _size = initSize;
  }else{
   _capacity=0;
  }
 }
 }

template <class T>
Vector<T>::Vector( const std::initializer_list<T> &il)
 :Vector()
{
 for(auto & i : il)
  pushBack(i);
}
template <class T>
Vector<T>::Vector(const T *data,size_t n)
 :Vector()
{
 if(resizeCapacity(n))
 {
  for(size_t i=0;i!=n;++i)
   new (_data+i) T(data[i]);
  _size = n;
 }
}
template <class T>
Vector<T>::Vector( const Vector<T> & vec)
 :
_data(mman.allocateAs<T*>(vec._capacity)),
  _capacity(0),
  _size(0)
{
 if(_data)
 {
  _capacity = vec._capacity;
  _size = vec._size;
  auto srcData=vec._data;
  for(size_t i=0;i!=_size;++i)
   new (_data+i) T(srcData[i]);
 }
}

template <class T>
Vector<T>& Vector<T>::operator=(const Vector<T> & vec)
{
 if(resize(vec._size))
 {
  auto src=vec._data;
  for(size_t i=0;i!=_size;++i)
   _data[i]=src[i];
 }
 return *this;
}

template <class T>
Vector<T>::Vector(Vector<T> && vec)
 :
_data(vec._data),_capacity(vec._capacity),_size(vec._size)
{
 vec._data = nullptr;
 vec._capacity = 0;
 vec._size = 0;
}

template <class T>
Vector<T>& Vector<T>::operator=(Vector<T> && vec)
{
 _data=vec._data;
 _capacity=vec._capacity;
 _size = vec._size;
 vec._data = nullptr;
 vec._capacity = 0;
 vec._size = 0;
 return *this;
}

template <class T>
Vector<T>::~Vector()
{
 if(_data!=nullptr)
 {
  for(size_t i=0;i!=_size;++i)
   _data[i].~T();
  memMan().deallocate(_data);
  _data=nullptr;
  _capacity = 0;
  _size = 0;
 }
}
template <class T>
template <class CastType>
Vector<CastType> && Vector<T>::castMove()
{
 _capacity /= sizeof(CastType);
 _size /= sizeof(CastType);
 return std::move(*reinterpret_cast<Vector<CastType>*>(this));
}
template <class T>
T Vector<T>::popBack()
{
 ((_size > 0) ? (void)0 : report_assert_error("/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/templates_implementation/data_structures/Vector.h", 137, __PRETTY_FUNCTION__, "_size > 0"));
 adjustCapacityForOneLess();
 return _data[--_size];
}
template <class T>
void Vector<T>::pushBack(T t)
{
 if(adjustCapacityForOneMore())
 {
  ++_size;
  new (_data + _size - 1) T(t);
 }
}
template <class T>
template <class ... Args>
void Vector<T>::emplaceBack(Args && ... args)
{
 if(adjustCapacityForOneMore())
 {
  ++_size;
  new (_data + _size -1) T(std::forward<Args>(args)...);
 }
}

template <class T>
void Vector<T>::clear()
{
 _size = 0;
 resizeCapacity(MINIMAL_CAPACITY);
}
template <class T>
void Vector<T>::erase(size_t i)
{
 if(i<_size && adjustCapacityForOneLess())
 {
  --_size;
  for(size_t j=i;j!=_size;++j)
   _data[j]=_data[j+1];
 }
}

template <class T>
Vector<T>& Vector<T>::append(const Vector<T> &vec,size_t len)
{
 if(len > vec.size() )len=vec.size();
 for(size_t i=0;i!=len;++i)
  pushBack(vec[i]);
 return *this;
}
template <class T>
size_t Vector<T>::insert(size_t i,const T & t)
{
 if(i > _size || !adjustCapacityForOneLess())
  return 0xffffffffffffffffUL;
 ++_size;
 for(size_t j = _size-1;j!=i;--j)
  _data[j] = _data[j-1];
 _data[i]=t;
 return i;
}

template <class T>
bool Vector<T>::resize(size_t newSize)
{
 size_t desiredCapacity = (newSize < MINIMAL_CAPACITY?MINIMAL_CAPACITY:newSize);
 if(resizeCapacity(desiredCapacity))
  _size=newSize;
 return (_size==newSize && _capacity==desiredCapacity);
}

template <class T>
bool Vector<T>::ensureEnoughCapacity(size_t capacity)
{
 if(capacity > _capacity)
  return resizeCapacity(capacity);
 return true;
}

template <class T>
bool Vector<T>::resizeCapacity(size_t capacity)
{
 if(this->_capacity == capacity)
  return true;
 void *newData=nullptr;
 if(_data)
  newData=mman.reallocate(_data, capacity * sizeof(T));
 else
  newData=mman.allocate(capacity*sizeof(T));
 if(!newData)
  return false;


 _data = reinterpret_cast<T*>(newData);
 this->_capacity = capacity;
 return true;
}

template <class T>
bool Vector<T>::adjustCapacityForOneMore()
{
 if(_size+1 > _capacity)
  return resizeCapacity(getIncrementalSize(_capacity));
 return true;
}

template <class T>
bool Vector<T>::adjustCapacityForOneLess()
{


 size_t advisedCapacity = (_size==0?MINIMAL_CAPACITY : getIncrementalSize(_size-1) );
 if(advisedCapacity < MINIMAL_CAPACITY)
  advisedCapacity=MINIMAL_CAPACITY;
 if(advisedCapacity < _capacity)
  return resizeCapacity(advisedCapacity);
 return true;

}


template <class T>
Output & operator<<(Output &out,const Vector<T> & vec)
{
 for(size_t i=0;i!=vec.size();++i)
  out << vec[i];
 return out;
}
# 111 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/data_structures/Vector.h" 2
# 16 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMap.h" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMemoryDefinition.h" 1
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMemoryDefinition.h"
class VirtualMemoryDefinition{
public:
 static constexpr size_t PAGE_BITS=12;
 static constexpr size_t ENTRY_BITS=3;
 static constexpr size_t ENTRY_SIZE=(1<<ENTRY_BITS);
 static constexpr size_t ENTRY_NUM_OF_EACH_TABLE = (1 << (PAGE_BITS - ENTRY_BITS));
 static constexpr size_t PAGE_SIZE=(1u<<PAGE_BITS);

 static constexpr size_t MEMORY_ATTR_NORMAL=0;
 static constexpr size_t MEMORY_ATTR_PERIPHERAL=1;
 static constexpr size_t MEMORY_ATTR_NON_CACHEABLE=2;
 static constexpr size_t MEMORY_AP_RW = 0;
 static constexpr size_t MEMORY_AP_RO = 1;


 static const size_t MAP_SIZE[4];
};
# 17 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualMap.h" 2





class VirtualMap{
public:
 using _D = VirtualMemoryDefinition;

 VirtualMap();
 VirtualMap(size_t phyPageStart,size_t pageCount,bool global,const void *vaAddr,size_t addrBits);
 ~VirtualMap();
 VirtualMap(const VirtualMap &rhs)=delete; VirtualMap & operator=(const VirtualMap &rhs)=delete;







 void mapL0();
 void mapL1();
 void mapL2();






 void mapL3(const Vector<AddressSpaceDescriptor> &descr);

 bool globalPages()const { return _global;}
 void globalPages(bool v){ _global=v;}

 __attribute__((always_inline)) inline Descriptor4KBL0* l0Table() { return _l0Table;}
 __attribute__((always_inline)) inline void l0Table(Descriptor4KBL0* l0Table) { _l0Table = l0Table;}
 __attribute__((always_inline)) inline Descriptor4KBL1* l1Table() { return _l1Table;}
 __attribute__((always_inline)) inline void l1Table(Descriptor4KBL1* l1Table) { _l1Table = l1Table;}
 __attribute__((always_inline)) inline Descriptor4KBL2* l2Table() { return _l2Table;}
 __attribute__((always_inline)) inline void l2Table(Descriptor4KBL2* l2Table) { _l2Table = l2Table;}
 __attribute__((always_inline)) inline Descriptor4KBL3* l3Table() { return _l3Table;}
 __attribute__((always_inline)) inline void l3Table(Descriptor4KBL3* l3Table) { _l3Table = l3Table;}

private:
 void allocateTables();
private:
 Descriptor4KBL0 * _l0Table;
 Descriptor4KBL1 * _l1Table;
 Descriptor4KBL2 * _l2Table;
 Descriptor4KBL3 * _l3Table;
 size_t _sizes[4];

 VirtualAddress _startAddr;
 const void * _phyAddr;
 size_t _pageCount;
 bool _global;

};
# 8 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/memory/VirtualMap.cpp" 2

# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstring" 1 3
# 39 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstring" 3
       
# 40 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstring" 3


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 1 3 4
# 10 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/_ansi.h" 1 3 4
# 15 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/_ansi.h" 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/newlib.h" 1 3 4
# 14 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/newlib.h" 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/_newlib_version.h" 1 3 4
# 15 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/newlib.h" 2 3 4
# 16 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/_ansi.h" 2 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/config.h" 1 3 4



# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/ieeefp.h" 1 3 4
# 5 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/config.h" 2 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/features.h" 1 3 4
# 25 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/features.h" 3 4

# 25 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/features.h" 3 4
extern "C" {
# 516 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/features.h" 3 4
}
# 6 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/config.h" 2 3 4
# 17 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/_ansi.h" 2 3 4
# 11 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 2 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 1 3 4
# 9 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
extern "C" {



# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/_ansi.h" 1 3 4
# 14 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 2 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 1 3 4
# 15 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 2 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/_types.h" 1 3 4
# 24 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/_types.h" 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_types.h" 1 3 4
# 32 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_types.h" 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 1 3 4
# 37 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 3 4
extern "C" {



typedef signed char __int8_t;

typedef unsigned char __uint8_t;
# 55 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 3 4
typedef short int __int16_t;

typedef short unsigned int __uint16_t;
# 77 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 3 4
typedef int __int32_t;

typedef unsigned int __uint32_t;
# 103 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 3 4
typedef long int __int64_t;

typedef long unsigned int __uint64_t;
# 134 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 3 4
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;
# 160 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 3 4
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;
# 182 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 3 4
typedef int __int_least32_t;

typedef unsigned int __uint_least32_t;
# 200 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 3 4
typedef long int __int_least64_t;

typedef long unsigned int __uint_least64_t;
# 214 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 3 4
typedef long int __intmax_t;







typedef long unsigned int __uintmax_t;







typedef long int __intptr_t;

typedef long unsigned int __uintptr_t;
# 247 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_default_types.h" 3 4
}
# 33 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/machine/_types.h" 2 3 4


typedef long signed int _ssize_t;
# 25 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/_types.h" 2 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/lock.h" 1 3 4





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 26 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/_types.h" 2 3 4


typedef long __blkcnt_t;



typedef long __blksize_t;



typedef __uint64_t __fsblkcnt_t;



typedef __uint32_t __fsfilcnt_t;



typedef long _off_t;





typedef int __pid_t;



typedef short __dev_t;



typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



typedef __uint32_t __id_t;







typedef unsigned short __ino_t;
# 88 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/_types.h" 3 4
typedef __uint32_t __mode_t;





__extension__ typedef long long _off64_t;





typedef _off_t __off_t;


typedef _off64_t __loff_t;


typedef long __key_t;







typedef long _fpos_t;
# 129 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/_types.h" 3 4
typedef long unsigned int __size_t;
# 156 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/_types.h" 3 4
typedef _ssize_t __ssize_t;


# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 1 3 4
# 357 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 160 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/_types.h" 2 3 4



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;



typedef unsigned long __clock_t;


typedef long __time_t;


typedef unsigned long __clockid_t;


typedef unsigned long __timer_t;


typedef __uint8_t __sa_family_t;



typedef __uint32_t __socklen_t;


typedef unsigned short __nlink_t;
typedef long __suseconds_t;
typedef unsigned long __useconds_t;




typedef char * __va_list;
# 16 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 2 3 4
# 25 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
typedef unsigned int __ULong;
# 38 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
struct _reent;

struct __locale_t;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 93 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 117 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 181 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                                          ;
  int (* _write) (struct _reent *, void *, const char *, int)

                                   ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _off_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 287 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 319 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 569 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];


  int _unspecified_locale_info;
  struct __locale_t *_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;



  struct _atexit *_atexit;
  struct _atexit _atexit0;



  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 766 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);
# 792 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/reent.h" 3 4
}
# 12 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 2 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/cdefs.h" 1 3 4
# 45 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/cdefs.h" 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 1 3 4
# 46 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/cdefs.h" 2 3 4
# 13 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 2 3 4




# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/lib/gcc/aarch64-elf/7.2.1/include/stddef.h" 1 3 4
# 18 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 2 3 4





extern "C" {

void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void * , const void * , size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *, const char *);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *, const char *);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *, const char *, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *, const char *, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);

char *strtok (char *, const char *);

size_t strxfrm (char *, const char *, size_t);
# 102 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 3 4
char *_strdup_r (struct _reent *, const char *);



char *_strndup_r (struct _reent *, const char *, size_t);
# 133 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 3 4
char * _strerror_r (struct _reent *, int, int, int *);
# 155 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 3 4
char *strsignal (int __signo);
# 192 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 3 4
# 1 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/sys/string.h" 1 3 4
# 193 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/libc/usr/include/string.h" 2 3 4

}
# 43 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstring" 2 3
# 71 "/home/francis/gcc-linaro-7.2.1-2017.11-x86_64_aarch64-elf/aarch64-elf/include/c++/7.2.1/cstring" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }

  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }

  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }



}
# 10 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/memory/VirtualMap.cpp" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/asm_instructions.h" 1
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/asm_instructions.h"
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/system_common_registers.h" 1
# 10 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/system_common_registers.h"

# 10 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/arch/common_aarch64/registers/system_common_registers.h"
class RegCurrentEL
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:2;
            uint32_t EL:2;
            uint32_t RES0_1:28;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegCurrentEL& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegCurrentEL & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegCurrentEL & setMandatoryFields()
    {
        RES0_0 = 0;
        EL = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegCurrentEL copy()const volatile
    {
     RegCurrentEL res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegCurrentEL copy()const
    {
     RegCurrentEL res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegCurrentEL: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegCurrentEL*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegCurrentEL make(uint32_t val)
    {
        RegCurrentEL res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegCurrentEL read()
    {
        RegCurrentEL res;
        __asm__ __volatile__("mrs %0,CurrentEL\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegCurrentEL & update()
    {
        __asm__ __volatile__("mrs %0,CurrentEL\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr CurrentEL,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDAIF
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:6;
            uint32_t F:1;
            uint32_t I:1;
            uint32_t A:1;
            uint32_t D:1;
            uint32_t RES0_1:22;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegDAIF& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegDAIF & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegDAIF & setMandatoryFields()
    {
        RES0_0 = 0;
        F = 0;
        I = 0;
        A = 0;
        D = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegDAIF copy()const volatile
    {
     RegDAIF res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegDAIF copy()const
    {
     RegDAIF res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegDAIF: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "F = " << F << ", "
                << "I = " << I << ", "
                << "A = " << A << ", "
                << "D = " << D << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegDAIF*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegDAIF make(uint32_t val)
    {
        RegDAIF res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegDAIF read()
    {
        RegDAIF res;
        __asm__ __volatile__("mrs %0,DAIF\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegDAIF & update()
    {
        __asm__ __volatile__("mrs %0,DAIF\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr DAIF,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegVBAR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t Addr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegVBAR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegVBAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegVBAR_EL1 & setMandatoryFields()
    {
        Addr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegVBAR_EL1 copy()const volatile
    {
     RegVBAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegVBAR_EL1 copy()const
    {
     RegVBAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegVBAR_EL1: ";
            kout
                << "Addr = " << Hex(Addr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegVBAR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegVBAR_EL1 make(uint64_t val)
    {
        RegVBAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegVBAR_EL1 read()
    {
        RegVBAR_EL1 res;
        __asm__ __volatile__("mrs %0,VBAR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegVBAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,VBAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr VBAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t returnAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegELR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegELR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegELR_EL1 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegELR_EL1 copy()const volatile
    {
     RegELR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegELR_EL1 copy()const
    {
     RegELR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegELR_EL1: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegELR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegELR_EL1 make(uint64_t val)
    {
        RegELR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegELR_EL1 read()
    {
        RegELR_EL1 res;
        __asm__ __volatile__("mrs %0,ELR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegELR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ELR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t returnAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegELR_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegELR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegELR_EL2 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegELR_EL2 copy()const volatile
    {
     RegELR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegELR_EL2 copy()const
    {
     RegELR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegELR_EL2: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegELR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegELR_EL2 make(uint64_t val)
    {
        RegELR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegELR_EL2 read()
    {
        RegELR_EL2 res;
        __asm__ __volatile__("mrs %0,ELR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegELR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ELR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegELR_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t returnAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegELR_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegELR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegELR_EL3 & setMandatoryFields()
    {
        returnAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegELR_EL3 copy()const volatile
    {
     RegELR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegELR_EL3 copy()const
    {
     RegELR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegELR_EL3: ";
            kout
                << "returnAddr = " << Hex(returnAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegELR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegELR_EL3 make(uint64_t val)
    {
        RegELR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegELR_EL3 read()
    {
        RegELR_EL3 res;
        __asm__ __volatile__("mrs %0,ELR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegELR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,ELR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ELR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t ISS:25;
            uint32_t IL:1;
            uint32_t EC:6;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegESR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegESR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegESR_EL1 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegESR_EL1 copy()const volatile
    {
     RegESR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegESR_EL1 copy()const
    {
     RegESR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegESR_EL1: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegESR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegESR_EL1 make(uint32_t val)
    {
        RegESR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegESR_EL1 read()
    {
        RegESR_EL1 res;
        __asm__ __volatile__("mrs %0,ESR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegESR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ESR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL2
{
public:
    using ScaleType=uint32_t;
            uint32_t ISS:25;
            uint32_t IL:1;
            uint32_t EC:6;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegESR_EL2& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegESR_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegESR_EL2 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegESR_EL2 copy()const volatile
    {
     RegESR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegESR_EL2 copy()const
    {
     RegESR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegESR_EL2: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegESR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegESR_EL2 make(uint32_t val)
    {
        RegESR_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegESR_EL2 read()
    {
        RegESR_EL2 res;
        __asm__ __volatile__("mrs %0,ESR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegESR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ESR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegESR_EL3
{
public:
    using ScaleType=uint32_t;
            uint32_t ISS:25;
            uint32_t IL:1;
            uint32_t EC:6;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegESR_EL3& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegESR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegESR_EL3 & setMandatoryFields()
    {
        ISS = 0;
        IL = 0;
        EC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegESR_EL3 copy()const volatile
    {
     RegESR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegESR_EL3 copy()const
    {
     RegESR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegESR_EL3: ";
            kout
                << "ISS = " << Hex(ISS) << ", "
                << "IL = " << IL << ", "
                << "EC = " << Hex(EC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegESR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegESR_EL3 make(uint32_t val)
    {
        RegESR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegESR_EL3 read()
    {
        RegESR_EL3 res;
        __asm__ __volatile__("mrs %0,ESR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegESR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,ESR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ESR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t faultAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegFAR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegFAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegFAR_EL1 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegFAR_EL1 copy()const volatile
    {
     RegFAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL1 copy()const
    {
     RegFAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegFAR_EL1: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegFAR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegFAR_EL1 make(uint64_t val)
    {
        RegFAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegFAR_EL1 read()
    {
        RegFAR_EL1 res;
        __asm__ __volatile__("mrs %0,FAR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr FAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t faultAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegFAR_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegFAR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegFAR_EL2 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegFAR_EL2 copy()const volatile
    {
     RegFAR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL2 copy()const
    {
     RegFAR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegFAR_EL2: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegFAR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegFAR_EL2 make(uint64_t val)
    {
        RegFAR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegFAR_EL2 read()
    {
        RegFAR_EL2 res;
        __asm__ __volatile__("mrs %0,FAR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr FAR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegFAR_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t faultAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegFAR_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegFAR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegFAR_EL3 & setMandatoryFields()
    {
        faultAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegFAR_EL3 copy()const volatile
    {
     RegFAR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL3 copy()const
    {
     RegFAR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegFAR_EL3: ";
            kout
                << "faultAddr = " << Hex(faultAddr) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegFAR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegFAR_EL3 make(uint64_t val)
    {
        RegFAR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegFAR_EL3 read()
    {
        RegFAR_EL3 res;
        __asm__ __volatile__("mrs %0,FAR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegFAR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,FAR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr FAR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSR_EL1 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSR_EL1 copy()const volatile
    {
     RegSPSR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL1 copy()const
    {
     RegSPSR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSR_EL1: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSR_EL1 make(uint32_t val)
    {
        RegSPSR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSR_EL1 read()
    {
        RegSPSR_EL1 res;
        __asm__ __volatile__("mrs %0,SPSR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL2
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSR_EL2& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSR_EL2 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSR_EL2 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSR_EL2 copy()const volatile
    {
     RegSPSR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL2 copy()const
    {
     RegSPSR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSR_EL2: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSR_EL2 make(uint32_t val)
    {
        RegSPSR_EL2 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSR_EL2 read()
    {
        RegSPSR_EL2 res;
        __asm__ __volatile__("mrs %0,SPSR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSR_EL3
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSR_EL3& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSR_EL3 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSR_EL3 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSR_EL3 copy()const volatile
    {
     RegSPSR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL3 copy()const
    {
     RegSPSR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSR_EL3: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSR_EL3 make(uint32_t val)
    {
        RegSPSR_EL3 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSR_EL3 read()
    {
        RegSPSR_EL3 res;
        __asm__ __volatile__("mrs %0,SPSR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,SPSR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP copy()const volatile
    {
     RegSP res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP copy()const
    {
     RegSP res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP make(uint64_t val)
    {
        RegSP res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP read()
    {
        RegSP res;
        __asm__ __volatile__("mrs %0,SP\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP & update()
    {
        __asm__ __volatile__("mrs %0,SP\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL0
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL0& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL0 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL0 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL0 copy()const volatile
    {
     RegSP_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL0 copy()const
    {
     RegSP_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL0: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL0 make(uint64_t val)
    {
        RegSP_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL0 read()
    {
        RegSP_EL0 res;
        __asm__ __volatile__("mrs %0,SP_EL0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL0\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL1 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL1 copy()const volatile
    {
     RegSP_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL1 copy()const
    {
     RegSP_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL1: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL1 make(uint64_t val)
    {
        RegSP_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL1 read()
    {
        RegSP_EL1 res;
        __asm__ __volatile__("mrs %0,SP_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL2 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL2 copy()const volatile
    {
     RegSP_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL2 copy()const
    {
     RegSP_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL2: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL2 make(uint64_t val)
    {
        RegSP_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL2 read()
    {
        RegSP_EL2 res;
        __asm__ __volatile__("mrs %0,SP_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSP_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t SP:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegSP_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSP_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSP_EL3 & setMandatoryFields()
    {
        SP = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSP_EL3 copy()const volatile
    {
     RegSP_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSP_EL3 copy()const
    {
     RegSP_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSP_EL3: ";
            kout
                << "SP = " << SP << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSP_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSP_EL3 make(uint64_t val)
    {
        RegSP_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSP_EL3 read()
    {
        RegSP_EL3 res;
        __asm__ __volatile__("mrs %0,SP_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSP_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,SP_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SP_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegNZCV
{
public:
    using ScaleType=uint64_t;
            uint64_t RES0_0:28;
            uint64_t V:1;
            uint64_t C:1;
            uint64_t Z:1;
            uint64_t N:1;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegNZCV& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegNZCV & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegNZCV & setMandatoryFields()
    {
        RES0_0 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegNZCV copy()const volatile
    {
     RegNZCV res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegNZCV copy()const
    {
     RegNZCV res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegNZCV: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegNZCV*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegNZCV make(uint64_t val)
    {
        RegNZCV res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegNZCV read()
    {
        RegNZCV res;
        __asm__ __volatile__("mrs %0,NZCV\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegNZCV & update()
    {
        __asm__ __volatile__("mrs %0,NZCV\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr NZCV,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPAN
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:22;
            uint32_t PAN:1;
            uint32_t RES0_1:9;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegPAN& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegPAN & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegPAN & setMandatoryFields()
    {
        RES0_0 = 0;
        PAN = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegPAN copy()const volatile
    {
     RegPAN res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegPAN copy()const
    {
     RegPAN res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegPAN: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "PAN = " << PAN << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegPAN*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegPAN make(uint32_t val)
    {
        RegPAN res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegPAN read()
    {
        RegPAN res;
        __asm__ __volatile__("mrs %0,PAN\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegPAN & update()
    {
        __asm__ __volatile__("mrs %0,PAN\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr PAN,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSPSel
{
public:
    using ScaleType=uint32_t;
            uint32_t SP:1;
            uint32_t RES0_0:31;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSPSel& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSPSel & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSPSel & setMandatoryFields()
    {
        SP = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSPSel copy()const volatile
    {
     RegSPSel res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSPSel copy()const
    {
     RegSPSel res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSPSel: ";
            kout
                << "SP = " << SP << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSPSel*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSPSel make(uint32_t val)
    {
        RegSPSel res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSPSel read()
    {
        RegSPSel res;
        __asm__ __volatile__("mrs %0,SPSel\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSPSel & update()
    {
        __asm__ __volatile__("mrs %0,SPSel\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SPSel,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegUAO
{
public:
    using ScaleType=uint64_t;
            uint64_t RES0_0:23;
            uint64_t UAO:1;
            uint64_t RES0_1:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegUAO& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegUAO & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegUAO & setMandatoryFields()
    {
        RES0_0 = 0;
        UAO = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegUAO copy()const volatile
    {
     RegUAO res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegUAO copy()const
    {
     RegUAO res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegUAO: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "UAO = " << UAO << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegUAO*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegUAO make(uint64_t val)
    {
        RegUAO res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegUAO read()
    {
        RegUAO res;
        __asm__ __volatile__("mrs %0,UAO\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegUAO & update()
    {
        __asm__ __volatile__("mrs %0,UAO\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr UAO,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPC
{
public:
    using ScaleType=uint64_t;
            uint64_t PC:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegPC& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegPC & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegPC & setMandatoryFields()
    {
        PC = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegPC copy()const volatile
    {
     RegPC res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegPC copy()const
    {
     RegPC res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegPC: ";
            kout
                << "PC = " << Hex(PC) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegPC*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegPC make(uint64_t val)
    {
        RegPC res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegPC read()
    {
        RegPC res;
        __asm__ __volatile__("mrs %0,PC\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegPC & update()
    {
        __asm__ __volatile__("mrs %0,PC\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr PC,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTCR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t T0SZ:6;
            uint64_t RES0_0:1;
            uint64_t EPD0:1;
            uint64_t IRGN0:2;
            uint64_t ORGN0:2;
            uint64_t SH0:2;
            uint64_t TG0:2;
            uint64_t T1SZ:6;
            uint64_t A1:1;
            uint64_t EPD1:1;
            uint64_t IRGN1:2;
            uint64_t ORGN1:2;
            uint64_t SH1:2;
            uint64_t TG1:2;
            uint64_t IPS:3;
            uint64_t RES0_1:1;
            uint64_t AS:1;
            uint64_t TBI0:1;
            uint64_t TBI1:1;
            uint64_t HA:1;
            uint64_t HD:1;
            uint64_t HPD0:1;
            uint64_t HPD1:1;
            uint64_t HWU059:1;
            uint64_t HWU060:1;
            uint64_t HWU061:1;
            uint64_t HWU062:1;
            uint64_t HWU159:1;
            uint64_t HWU160:1;
            uint64_t HWU161:1;
            uint64_t HWU162:1;
            uint64_t RES0_2:2;
            uint64_t NFD0:1;
            uint64_t NFD1:1;
            uint64_t RES0_3:9;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegTCR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegTCR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegTCR_EL1 & setMandatoryFields()
    {
        T0SZ = 0;
        RES0_0 = 0;
        EPD0 = 0;
        IRGN0 = 0;
        ORGN0 = 0;
        SH0 = 0;
        TG0 = 0;
        T1SZ = 0;
        A1 = 0;
        EPD1 = 0;
        IRGN1 = 0;
        ORGN1 = 0;
        SH1 = 0;
        TG1 = 0;
        IPS = 0;
        RES0_1 = 0;
        AS = 0;
        TBI0 = 0;
        TBI1 = 0;
        HA = 0;
        HD = 0;
        HPD0 = 0;
        HPD1 = 0;
        HWU059 = 0;
        HWU060 = 0;
        HWU061 = 0;
        HWU062 = 0;
        HWU159 = 0;
        HWU160 = 0;
        HWU161 = 0;
        HWU162 = 0;
        RES0_2 = 0;
        NFD0 = 0;
        NFD1 = 0;
        RES0_3 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegTCR_EL1 copy()const volatile
    {
     RegTCR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegTCR_EL1 copy()const
    {
     RegTCR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegTCR_EL1: ";
            kout
                << "T0SZ = " << T0SZ << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EPD0 = " << EPD0 << ", "
                << "IRGN0 = " << IRGN0 << ", "
                << "ORGN0 = " << ORGN0 << ", "
                << "SH0 = " << SH0 << ", "
                << "TG0 = " << TG0 << ", "
                << "T1SZ = " << T1SZ << ", "
                << "A1 = " << A1 << ", "
                << "EPD1 = " << EPD1 << ", "
                << "IRGN1 = " << IRGN1 << ", "
                << "ORGN1 = " << ORGN1 << ", "
                << "SH1 = " << SH1 << ", "
                << "TG1 = " << TG1 << ", "
                << "IPS = " << IPS << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "AS = " << AS << ", "
                << "TBI0 = " << TBI0 << ", "
                << "TBI1 = " << TBI1 << ", "
                << "HA = " << HA << ", "
                << "HD = " << HD << ", "
                << "HPD0 = " << HPD0 << ", "
                << "HPD1 = " << HPD1 << ", "
                << "HWU059 = " << HWU059 << ", "
                << "HWU060 = " << HWU060 << ", "
                << "HWU061 = " << HWU061 << ", "
                << "HWU062 = " << HWU062 << ", "
                << "HWU159 = " << HWU159 << ", "
                << "HWU160 = " << HWU160 << ", "
                << "HWU161 = " << HWU161 << ", "
                << "HWU162 = " << HWU162 << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "NFD0 = " << NFD0 << ", "
                << "NFD1 = " << NFD1 << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegTCR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegTCR_EL1 make(uint64_t val)
    {
        RegTCR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegTCR_EL1 read()
    {
        RegTCR_EL1 res;
        __asm__ __volatile__("mrs %0,TCR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegTCR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TCR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr TCR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegISR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t RES0_0:6;
            uint32_t F:1;
            uint32_t I:1;
            uint32_t A:1;
            uint32_t RES0_1:23;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegISR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegISR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegISR_EL1 & setMandatoryFields()
    {
        RES0_0 = 0;
        F = 0;
        I = 0;
        A = 0;
        RES0_1 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegISR_EL1 copy()const volatile
    {
     RegISR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegISR_EL1 copy()const
    {
     RegISR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegISR_EL1: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "F = " << F << ", "
                << "I = " << I << ", "
                << "A = " << A << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegISR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegISR_EL1 make(uint32_t val)
    {
        RegISR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegISR_EL1 read()
    {
        RegISR_EL1 res;
        __asm__ __volatile__("mrs %0,ISR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegISR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ISR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ISR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64ISAR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t RES0_0:4;
            uint64_t AES:4;
            uint64_t SHA1:4;
            uint64_t SHA2:4;
            uint64_t CRC32:4;
            uint64_t Atomic:4;
            uint64_t RES0_1:4;
            uint64_t RDM:4;
            uint64_t SHA3:4;
            uint64_t SM3:4;
            uint64_t SM4:4;
            uint64_t DP:4;
            uint64_t RES0_2:16;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64ISAR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 & setMandatoryFields()
    {
        RES0_0 = 0;
        AES = 0;
        SHA1 = 0;
        SHA2 = 0;
        CRC32 = 0;
        Atomic = 0;
        RES0_1 = 0;
        RDM = 0;
        SHA3 = 0;
        SM3 = 0;
        SM4 = 0;
        DP = 0;
        RES0_2 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 copy()const volatile
    {
     RegID_AA64ISAR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 copy()const
    {
     RegID_AA64ISAR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64ISAR0_EL1: ";
            kout
                << "RES0_0 = " << RES0_0 << ", "
                << "AES = " << AES << ", "
                << "SHA1 = " << SHA1 << ", "
                << "SHA2 = " << SHA2 << ", "
                << "CRC32 = " << CRC32 << ", "
                << "Atomic = " << Atomic << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "RDM = " << RDM << ", "
                << "SHA3 = " << SHA3 << ", "
                << "SM3 = " << SM3 << ", "
                << "SM4 = " << SM4 << ", "
                << "DP = " << DP << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64ISAR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64ISAR0_EL1 make(uint64_t val)
    {
        RegID_AA64ISAR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64ISAR0_EL1 read()
    {
        RegID_AA64ISAR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64ISAR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64ISAR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64ISAR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64ISAR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegCONTEXTIDR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t PROCID:32;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegCONTEXTIDR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 & setMandatoryFields()
    {
        PROCID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 copy()const volatile
    {
     RegCONTEXTIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 copy()const
    {
     RegCONTEXTIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegCONTEXTIDR_EL1: ";
            kout
                << "PROCID = " << PROCID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegCONTEXTIDR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegCONTEXTIDR_EL1 make(uint32_t val)
    {
        RegCONTEXTIDR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegCONTEXTIDR_EL1 read()
    {
        RegCONTEXTIDR_EL1 res;
        __asm__ __volatile__("mrs %0,CONTEXTIDR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegCONTEXTIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,CONTEXTIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr CONTEXTIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64PFR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t EL0:4;
            uint64_t EL1:4;
            uint64_t EL2:4;
            uint64_t EL3:4;
            uint64_t FP:4;
            uint64_t AdvSIMD:4;
            uint64_t GIC:4;
            uint64_t RAS:4;
            uint64_t SVE:4;
            uint64_t RES0_0:28;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64PFR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 & setMandatoryFields()
    {
        EL0 = 0;
        EL1 = 0;
        EL2 = 0;
        EL3 = 0;
        FP = 0;
        AdvSIMD = 0;
        GIC = 0;
        RAS = 0;
        SVE = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 copy()const volatile
    {
     RegID_AA64PFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 copy()const
    {
     RegID_AA64PFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64PFR0_EL1: ";
            kout
                << "EL0 = " << EL0 << ", "
                << "EL1 = " << EL1 << ", "
                << "EL2 = " << EL2 << ", "
                << "EL3 = " << EL3 << ", "
                << "FP = " << FP << ", "
                << "AdvSIMD = " << AdvSIMD << ", "
                << "GIC = " << GIC << ", "
                << "RAS = " << RAS << ", "
                << "SVE = " << SVE << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64PFR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64PFR0_EL1 make(uint64_t val)
    {
        RegID_AA64PFR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64PFR0_EL1 read()
    {
        RegID_AA64PFR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64PFR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64PFR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64PFR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64PFR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64MMFR1_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t HAFDBS:4;
            uint64_t VMIDBits:4;
            uint64_t VH:4;
            uint64_t HPDS:4;
            uint64_t LO:4;
            uint64_t PAN:4;
            uint64_t SpecSEI:4;
            uint64_t XNX:4;
            uint64_t RES0_0:32;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64MMFR1_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 & setMandatoryFields()
    {
        HAFDBS = 0;
        VMIDBits = 0;
        VH = 0;
        HPDS = 0;
        LO = 0;
        PAN = 0;
        SpecSEI = 0;
        XNX = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 copy()const volatile
    {
     RegID_AA64MMFR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 copy()const
    {
     RegID_AA64MMFR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64MMFR1_EL1: ";
            kout
                << "HAFDBS = " << HAFDBS << ", "
                << "VMIDBits = " << VMIDBits << ", "
                << "VH = " << VH << ", "
                << "HPDS = " << HPDS << ", "
                << "LO = " << LO << ", "
                << "PAN = " << PAN << ", "
                << "SpecSEI = " << SpecSEI << ", "
                << "XNX = " << XNX << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64MMFR1_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR1_EL1 make(uint64_t val)
    {
        RegID_AA64MMFR1_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR1_EL1 read()
    {
        RegID_AA64MMFR1_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64MMFR1_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR1_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64MMFR1_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64MMFR1_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegID_AA64MMFR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t PARange:4;
            uint64_t ASIDBits:4;
            uint64_t BigEnd:4;
            uint64_t SNSMem:4;
            uint64_t BigEndEL0:4;
            uint64_t TGran16:4;
            uint64_t TGran64:4;
            uint64_t TGran4:4;
            uint64_t RES0_0:32;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegID_AA64MMFR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 & setMandatoryFields()
    {
        PARange = 0;
        ASIDBits = 0;
        BigEnd = 0;
        SNSMem = 0;
        BigEndEL0 = 0;
        TGran16 = 0;
        TGran64 = 0;
        TGran4 = 0;
        RES0_0 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 copy()const volatile
    {
     RegID_AA64MMFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 copy()const
    {
     RegID_AA64MMFR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegID_AA64MMFR0_EL1: ";
            kout
                << "PARange = " << PARange << ", "
                << "ASIDBits = " << ASIDBits << ", "
                << "BigEnd = " << BigEnd << ", "
                << "SNSMem = " << SNSMem << ", "
                << "BigEndEL0 = " << BigEndEL0 << ", "
                << "TGran16 = " << Hex(TGran16) << ", "
                << "TGran64 = " << Hex(TGran64) << ", "
                << "TGran4 = " << Hex(TGran4) << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegID_AA64MMFR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR0_EL1 make(uint64_t val)
    {
        RegID_AA64MMFR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegID_AA64MMFR0_EL1 read()
    {
        RegID_AA64MMFR0_EL1 res;
        __asm__ __volatile__("mrs %0,ID_AA64MMFR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegID_AA64MMFR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,ID_AA64MMFR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr ID_AA64MMFR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMIDR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t Revision:4;
            uint32_t PartNum:12;
            uint32_t Architecture:4;
            uint32_t Variant:4;
            uint32_t Implementer:8;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegMIDR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMIDR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMIDR_EL1 & setMandatoryFields()
    {
        Revision = 0;
        PartNum = 0;
        Architecture = 0;
        Variant = 0;
        Implementer = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMIDR_EL1 copy()const volatile
    {
     RegMIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMIDR_EL1 copy()const
    {
     RegMIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMIDR_EL1: ";
            kout
                << "Revision = " << Revision << ", "
                << "PartNum = " << PartNum << ", "
                << "Architecture = " << Architecture << ", "
                << "Variant = " << Variant << ", "
                << "Implementer = " << Implementer << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMIDR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMIDR_EL1 make(uint32_t val)
    {
        RegMIDR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMIDR_EL1 read()
    {
        RegMIDR_EL1 res;
        __asm__ __volatile__("mrs %0,MIDR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMPIDR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t Aff0:8;
            uint64_t Aff1:8;
            uint64_t Aff2:8;
            uint64_t MT:1;
            uint64_t RES0_0:5;
            uint64_t U:1;
            uint64_t RES1_1:1;
            uint64_t Aff3:8;
            uint64_t RES0_2:24;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMPIDR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMPIDR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMPIDR_EL1 & setMandatoryFields()
    {
        Aff0 = 0;
        Aff1 = 0;
        Aff2 = 0;
        MT = 0;
        RES0_0 = 0;
        U = 0;
        RES1_1 = 1;
        Aff3 = 0;
        RES0_2 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMPIDR_EL1 copy()const volatile
    {
     RegMPIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMPIDR_EL1 copy()const
    {
     RegMPIDR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMPIDR_EL1: ";
            kout
                << "Aff0 = " << Aff0 << ", "
                << "Aff1 = " << Aff1 << ", "
                << "Aff2 = " << Aff2 << ", "
                << "MT = " << MT << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "U = " << U << ", "
                << "RES1_1 = " << RES1_1 << ", "
                << "Aff3 = " << Aff3 << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMPIDR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMPIDR_EL1 make(uint64_t val)
    {
        RegMPIDR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMPIDR_EL1 read()
    {
        RegMPIDR_EL1 res;
        __asm__ __volatile__("mrs %0,MPIDR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMPIDR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MPIDR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MPIDR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTTBR0_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t CnP:1;
            uint64_t BADDR:47;
            uint64_t ASID:16;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegTTBR0_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegTTBR0_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegTTBR0_EL1 & setMandatoryFields()
    {
        CnP = 0;
        BADDR = 0;
        ASID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegTTBR0_EL1 copy()const volatile
    {
     RegTTBR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegTTBR0_EL1 copy()const
    {
     RegTTBR0_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegTTBR0_EL1: ";
            kout
                << "CnP = " << CnP << ", "
                << "BADDR = " << Hex(BADDR) << ", "
                << "ASID = " << ASID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegTTBR0_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegTTBR0_EL1 make(uint64_t val)
    {
        RegTTBR0_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegTTBR0_EL1 read()
    {
        RegTTBR0_EL1 res;
        __asm__ __volatile__("mrs %0,TTBR0_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegTTBR0_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TTBR0_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr TTBR0_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegTTBR1_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t CnP:1;
            uint64_t BADDR:47;
            uint64_t ASID:16;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegTTBR1_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegTTBR1_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegTTBR1_EL1 & setMandatoryFields()
    {
        CnP = 0;
        BADDR = 0;
        ASID = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegTTBR1_EL1 copy()const volatile
    {
     RegTTBR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegTTBR1_EL1 copy()const
    {
     RegTTBR1_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegTTBR1_EL1: ";
            kout
                << "CnP = " << CnP << ", "
                << "BADDR = " << Hex(BADDR) << ", "
                << "ASID = " << ASID << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegTTBR1_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegTTBR1_EL1 make(uint64_t val)
    {
        RegTTBR1_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegTTBR1_EL1 read()
    {
        RegTTBR1_EL1 res;
        __asm__ __volatile__("mrs %0,TTBR1_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegTTBR1_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,TTBR1_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr TTBR1_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegPAR_EL1
{
public:
    using ScaleType=uint64_t;
    union {
        struct {
            uint64_t F:1;
            uint64_t RES0_0:6;
            uint64_t SH:2;
            uint64_t NS:1;
            uint64_t IMP_DEF_1:1;
            uint64_t RES1_2:1;
            uint64_t PA47_12:36;
            uint64_t PA51_48:4;
            uint64_t RES0_3:4;
            uint64_t ATTR:8;
        }__attribute__((packed)) S0;
        struct {
            uint64_t F:1;
            uint64_t FST:6;
            uint64_t RES0_0:1;
            uint64_t PTW:1;
            uint64_t S:1;
            uint64_t RES0_1:1;
            uint64_t RES1_2:1;
            uint64_t RES0_3:36;
            uint64_t IMP_DEF0:4;
            uint64_t IMP_DEF1:4;
            uint64_t IMP_DEF2:8;
        }__attribute__((packed)) S1;
    };
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegPAR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegPAR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegPAR_EL1 copy()const volatile
    {
     RegPAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegPAR_EL1 copy()const
    {
     RegPAR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegPAR_EL1: ";
        if(S0.F==0)
        {
            kout
                << "S0.F = " << S0.F << ", "
                << "S0.RES0_0 = " << S0.RES0_0 << ", "
                << "S0.SH = " << S0.SH << ", "
                << "S0.NS = " << S0.NS << ", "
                << "S0.IMP_DEF_1 = " << S0.IMP_DEF_1 << ", "
                << "S0.RES1_2 = " << S0.RES1_2 << ", "
                << "S0.PA47_12 = " << Hex(S0.PA47_12) << ", "
                << "S0.PA51_48 = " << Hex(S0.PA51_48) << ", "
                << "S0.RES0_3 = " << S0.RES0_3 << ", "
                << "S0.ATTR = " << S0.ATTR << ", "
                << "\n";
        }
        else
        {
            kout
                << "S1.F = " << S1.F << ", "
                << "S1.FST = " << S1.FST << ", "
                << "S1.RES0_0 = " << S1.RES0_0 << ", "
                << "S1.PTW = " << S1.PTW << ", "
                << "S1.S = " << S1.S << ", "
                << "S1.RES0_1 = " << S1.RES0_1 << ", "
                << "S1.RES1_2 = " << S1.RES1_2 << ", "
                << "S1.RES0_3 = " << S1.RES0_3 << ", "
                << "S1.IMP_DEF0 = " << S1.IMP_DEF0 << ", "
                << "S1.IMP_DEF1 = " << S1.IMP_DEF1 << ", "
                << "S1.IMP_DEF2 = " << S1.IMP_DEF2 << ", "
                << "\n";
        }
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegPAR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegPAR_EL1 make(uint64_t val)
    {
        RegPAR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegPAR_EL1 read()
    {
        RegPAR_EL1 res;
        __asm__ __volatile__("mrs %0,PAR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegPAR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,PAR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr PAR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL1
{
public:
    using ScaleType=uint64_t;
            uint64_t Attr0:8;
            uint64_t Attr1:8;
            uint64_t Attr2:8;
            uint64_t Attr3:8;
            uint64_t Attr4:8;
            uint64_t Attr5:8;
            uint64_t Attr6:8;
            uint64_t Attr7:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMAIR_EL1& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMAIR_EL1 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMAIR_EL1 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMAIR_EL1 copy()const volatile
    {
     RegMAIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL1 copy()const
    {
     RegMAIR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMAIR_EL1: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMAIR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMAIR_EL1 make(uint64_t val)
    {
        RegMAIR_EL1 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMAIR_EL1 read()
    {
        RegMAIR_EL1 res;
        __asm__ __volatile__("mrs %0,MAIR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MAIR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL2
{
public:
    using ScaleType=uint64_t;
            uint64_t Attr0:8;
            uint64_t Attr1:8;
            uint64_t Attr2:8;
            uint64_t Attr3:8;
            uint64_t Attr4:8;
            uint64_t Attr5:8;
            uint64_t Attr6:8;
            uint64_t Attr7:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMAIR_EL2& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMAIR_EL2 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMAIR_EL2 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMAIR_EL2 copy()const volatile
    {
     RegMAIR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL2 copy()const
    {
     RegMAIR_EL2 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMAIR_EL2: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMAIR_EL2*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMAIR_EL2 make(uint64_t val)
    {
        RegMAIR_EL2 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMAIR_EL2 read()
    {
        RegMAIR_EL2 res;
        __asm__ __volatile__("mrs %0,MAIR_EL2\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL2 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL2\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MAIR_EL2,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegMAIR_EL3
{
public:
    using ScaleType=uint64_t;
            uint64_t Attr0:8;
            uint64_t Attr1:8;
            uint64_t Attr2:8;
            uint64_t Attr3:8;
            uint64_t Attr4:8;
            uint64_t Attr5:8;
            uint64_t Attr6:8;
            uint64_t Attr7:8;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegMAIR_EL3& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegMAIR_EL3 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegMAIR_EL3 & setMandatoryFields()
    {
        Attr0 = 0;
        Attr1 = 0;
        Attr2 = 0;
        Attr3 = 0;
        Attr4 = 0;
        Attr5 = 0;
        Attr6 = 0;
        Attr7 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegMAIR_EL3 copy()const volatile
    {
     RegMAIR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL3 copy()const
    {
     RegMAIR_EL3 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegMAIR_EL3: ";
            kout
                << "Attr0 = " << Hex(Attr0) << ", "
                << "Attr1 = " << Hex(Attr1) << ", "
                << "Attr2 = " << Hex(Attr2) << ", "
                << "Attr3 = " << Hex(Attr3) << ", "
                << "Attr4 = " << Hex(Attr4) << ", "
                << "Attr5 = " << Hex(Attr5) << ", "
                << "Attr6 = " << Hex(Attr6) << ", "
                << "Attr7 = " << Hex(Attr7) << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegMAIR_EL3*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegMAIR_EL3 make(uint64_t val)
    {
        RegMAIR_EL3 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegMAIR_EL3 read()
    {
        RegMAIR_EL3 res;
        __asm__ __volatile__("mrs %0,MAIR_EL3\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegMAIR_EL3 & update()
    {
        __asm__ __volatile__("mrs %0,MAIR_EL3\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr MAIR_EL3,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegSCTLR_EL1
{
public:
    using ScaleType=uint32_t;
            uint32_t M:1;
            uint32_t A:1;
            uint32_t C:1;
            uint32_t SA:1;
            uint32_t SA0:1;
            uint32_t CP15BEN:1;
            uint32_t RES0_0:1;
            uint32_t ITD:1;
            uint32_t SED:1;
            uint32_t UMA:1;
            uint32_t RES0_1:1;
            uint32_t RES1_2:1;
            uint32_t I:1;
            uint32_t RES0_3:1;
            uint32_t DZE:1;
            uint32_t UCT:1;
            uint32_t nTWI:1;
            uint32_t RES0_4:1;
            uint32_t nTWE:1;
            uint32_t WXN:1;
            uint32_t RES1_5:1;
            uint32_t IESB:1;
            uint32_t RES1_6:1;
            uint32_t SPAN:1;
            uint32_t E0E:1;
            uint32_t EE:1;
            uint32_t UCI:1;
            uint32_t RES0_7:1;
            uint32_t nTLSMD:1;
            uint32_t LSMAOE:1;
            uint32_t RES0_8:2;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegSCTLR_EL1& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegSCTLR_EL1 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegSCTLR_EL1 & setMandatoryFields()
    {
        M = 0;
        A = 0;
        C = 0;
        SA = 0;
        SA0 = 0;
        CP15BEN = 0;
        RES0_0 = 0;
        ITD = 0;
        SED = 0;
        UMA = 0;
        RES0_1 = 0;
        RES1_2 = 1;
        I = 0;
        RES0_3 = 0;
        DZE = 0;
        UCT = 0;
        nTWI = 0;
        RES0_4 = 0;
        nTWE = 0;
        WXN = 0;
        RES1_5 = 1;
        IESB = 0;
        RES1_6 = 1;
        SPAN = 0;
        E0E = 0;
        EE = 0;
        UCI = 0;
        RES0_7 = 0;
        nTLSMD = 0;
        LSMAOE = 0;
        RES0_8 = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegSCTLR_EL1 copy()const volatile
    {
     RegSCTLR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegSCTLR_EL1 copy()const
    {
     RegSCTLR_EL1 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegSCTLR_EL1: ";
            kout
                << "M = " << M << ", "
                << "A = " << A << ", "
                << "C = " << C << ", "
                << "SA = " << SA << ", "
                << "SA0 = " << SA0 << ", "
                << "CP15BEN = " << CP15BEN << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "ITD = " << ITD << ", "
                << "SED = " << SED << ", "
                << "UMA = " << UMA << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "RES1_2 = " << RES1_2 << ", "
                << "I = " << I << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "DZE = " << DZE << ", "
                << "UCT = " << UCT << ", "
                << "nTWI = " << nTWI << ", "
                << "RES0_4 = " << RES0_4 << ", "
                << "nTWE = " << nTWE << ", "
                << "WXN = " << WXN << ", "
                << "RES1_5 = " << RES1_5 << ", "
                << "IESB = " << IESB << ", "
                << "RES1_6 = " << RES1_6 << ", "
                << "SPAN = " << SPAN << ", "
                << "E0E = " << E0E << ", "
                << "EE = " << EE << ", "
                << "UCI = " << UCI << ", "
                << "RES0_7 = " << RES0_7 << ", "
                << "nTLSMD = " << nTLSMD << ", "
                << "LSMAOE = " << LSMAOE << ", "
                << "RES0_8 = " << RES0_8 << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegSCTLR_EL1*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegSCTLR_EL1 make(uint32_t val)
    {
        RegSCTLR_EL1 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegSCTLR_EL1 read()
    {
        RegSCTLR_EL1 res;
        __asm__ __volatile__("mrs %0,SCTLR_EL1\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegSCTLR_EL1 & update()
    {
        __asm__ __volatile__("mrs %0,SCTLR_EL1\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr SCTLR_EL1,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDLR_EL0
{
public:
    using ScaleType=uint64_t;
            uint64_t RestartAddr:64;
    __attribute__((always_inline)) inline uint64_t get()const
    {
        return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline uint64_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint64_t*>(this);
    }

    __attribute__((always_inline)) inline RegDLR_EL0& set(uint64_t v)
    {
        *reinterpret_cast<uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegDLR_EL0 & set(uint64_t v)volatile
    {
        *reinterpret_cast<volatile uint64_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegDLR_EL0 & setMandatoryFields()
    {
        RestartAddr = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegDLR_EL0 copy()const volatile
    {
     RegDLR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegDLR_EL0 copy()const
    {
     RegDLR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegDLR_EL0: ";
            kout
                << "RestartAddr = " << RestartAddr << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegDLR_EL0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint64_t & asuint64_t()
    {
     return *reinterpret_cast<uint64_t*>(this);
    }
    __attribute__((always_inline)) inline const uint64_t & asuint64_t()const
    {
     return *reinterpret_cast<const uint64_t*>(this);
    }
    __attribute__((always_inline)) inline static RegDLR_EL0 make(uint64_t val)
    {
        RegDLR_EL0 res;
        *reinterpret_cast<uint64_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegDLR_EL0 read()
    {
        RegDLR_EL0 res;
        __asm__ __volatile__("mrs %0,DLR_EL0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegDLR_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,DLR_EL0\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr DLR_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));


class RegDSPSR_EL0
{
public:
    using ScaleType=uint32_t;
            uint32_t SPSel:1;
            uint32_t RES0_0:1;
            uint32_t EL:2;
            uint32_t ExeState:1;
            uint32_t RES0_1:1;
            uint32_t FIQMask:1;
            uint32_t IRQMask:1;
            uint32_t SErrorMask:1;
            uint32_t DebugMask:1;
            uint32_t RES0_2:10;
            uint32_t IL:1;
            uint32_t SoftwareStep:1;
            uint32_t PAN:1;
            uint32_t UAO:1;
            uint32_t RES0_3:4;
            uint32_t V:1;
            uint32_t C:1;
            uint32_t Z:1;
            uint32_t N:1;
    __attribute__((always_inline)) inline uint32_t get()const
    {
        return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline uint32_t get()const volatile
    {
        return *reinterpret_cast<const volatile uint32_t*>(this);
    }

    __attribute__((always_inline)) inline RegDSPSR_EL0& set(uint32_t v)
    {
        *reinterpret_cast<uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline volatile RegDSPSR_EL0 & set(uint32_t v)volatile
    {
        *reinterpret_cast<volatile uint32_t*>(this)=v;
        return *this;
    }
    __attribute__((always_inline)) inline RegDSPSR_EL0 & setMandatoryFields()
    {
        SPSel = 0;
        RES0_0 = 0;
        EL = 0;
        ExeState = 0;
        RES0_1 = 0;
        FIQMask = 0;
        IRQMask = 0;
        SErrorMask = 0;
        DebugMask = 0;
        RES0_2 = 0;
        IL = 0;
        SoftwareStep = 0;
        PAN = 0;
        UAO = 0;
        RES0_3 = 0;
        V = 0;
        C = 0;
        Z = 0;
        N = 0;
        return *this;
        }
    __attribute__((always_inline)) inline RegDSPSR_EL0 copy()const volatile
    {
     RegDSPSR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline RegDSPSR_EL0 copy()const
    {
     RegDSPSR_EL0 res;
     res.set(this->get());
     return res;
    }
    __attribute__((always_inline)) inline void dump()const volatile
    {
        kout << "RegDSPSR_EL0: ";
            kout
                << "SPSel = " << SPSel << ", "
                << "RES0_0 = " << RES0_0 << ", "
                << "EL = " << EL << ", "
                << "ExeState = " << ExeState << ", "
                << "RES0_1 = " << RES0_1 << ", "
                << "FIQMask = " << FIQMask << ", "
                << "IRQMask = " << IRQMask << ", "
                << "SErrorMask = " << SErrorMask << ", "
                << "DebugMask = " << DebugMask << ", "
                << "RES0_2 = " << RES0_2 << ", "
                << "IL = " << IL << ", "
                << "SoftwareStep = " << SoftwareStep << ", "
                << "PAN = " << PAN << ", "
                << "UAO = " << UAO << ", "
                << "RES0_3 = " << RES0_3 << ", "
                << "V = " << V << ", "
                << "C = " << C << ", "
                << "Z = " << Z << ", "
                << "N = " << N << ", "
                << "\n";
    }
    __attribute__((always_inline)) inline void dump()const
    {
     reinterpret_cast<volatile const RegDSPSR_EL0*>(this)->dump();
    }
    __attribute__((always_inline)) inline uint32_t & asuint32_t()
    {
     return *reinterpret_cast<uint32_t*>(this);
    }
    __attribute__((always_inline)) inline const uint32_t & asuint32_t()const
    {
     return *reinterpret_cast<const uint32_t*>(this);
    }
    __attribute__((always_inline)) inline static RegDSPSR_EL0 make(uint32_t val)
    {
        RegDSPSR_EL0 res;
        *reinterpret_cast<uint32_t*>(&res)=val;
        return res;
    }
    __attribute__((always_inline)) inline static RegDSPSR_EL0 read()
    {
        RegDSPSR_EL0 res;
        __asm__ __volatile__("mrs %0,DSPSR_EL0\n\t":"=r"(res));
        return res;
    }
    __attribute__((always_inline)) inline RegDSPSR_EL0 & update()
    {
        __asm__ __volatile__("mrs %0,DSPSR_EL0\n\t":"=r"(*this));
        return *this;
    }
    __attribute__((always_inline)) inline void write()const
    {
        __asm__ __volatile__("msr DSPSR_EL0,%0\n\t"::"r"(*this));
    }
}__attribute__((packed));
# 13 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/asm_instructions.h" 2
# 132 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/asm_instructions.h"
__attribute__((always_inline)) inline void asm_nop();
__attribute__((always_inline)) inline void asm_isb();
__attribute__((always_inline)) inline void asm_eret();
__attribute__((always_inline)) inline RegPAR_EL1 asm_at(uint64_t va);
__attribute__((always_inline)) inline void asm_svc(uint16_t imm);
__attribute__((always_inline)) inline void asm_wfe();
__attribute__((always_inline)) inline __attribute__((noreturn)) void asm_wfe_loop();
__attribute__((always_inline)) inline void asm_tlbi_aside1(uint16_t asid);
__attribute__((always_inline)) inline void asm_tlbi_allel1();
__attribute__((always_inline)) inline void asm_tbli_vmallel1();



void asm_nop()
{
 __asm__ __volatile__("nop \n\t");
}
void asm_isb()
{
 __asm__ __volatile__("isb \n\t");
}
void asm_eret()
{
 __asm__ __volatile__("eret \n\t");
}
RegPAR_EL1 asm_at(uint64_t va)
{
 __asm__ __volatile__("at S1E1R,%0 \n\t"::"r"(va));
 return RegPAR_EL1::read();
}
void asm_svc(uint16_t imm)
{
 __asm__ __volatile__("svc %0"::"i"(imm));
}
void asm_wfe()
{
 __asm__ __volatile__("wfe \n\t");
}
void asm_wfe_loop()
{
 while(true)
  asm_wfe();
}


void asm_tlbi_aside1(uint16_t asid)
{
 __asm__ __volatile__(
   "tlbi aside1,%0 \n\t"
   ::"r"(static_cast<uint64_t>(asid)<<(64 - 16))
 );
}

void asm_tlbi_allel1()
{
 __asm__ __volatile__("tlbi ALLE1 \n\t");
}
void asm_tbli_vmallel1()
{
 __asm__ __volatile__("tlbi  VMALLE1 \n\t");
}
# 11 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/memory/VirtualMap.cpp" 2
# 1 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualManager.h" 1
# 18 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/include/memory/VirtualManager.h"
class VirtualManager{
public:
 using InitFunctionPtr = void (*)();
 using _D = VirtualMemoryDefinition;

 VirtualManager();






 void enableMMU(InitFunctionPtr jmpFunc,void *newSp);




 void enableTTBR0(bool enable);
 void updateTTBR0(Descriptor4KBL0 *l0Table);
 void updateTTBR1(Descriptor4KBL0 *l0Table);
 void* translateVAToPA(const void * va);
 uint64_t translateVAToPA(uint64_t va);

 __attribute__((always_inline)) inline size_t addressBits() const { return _addressBits;}
 __attribute__((always_inline)) inline size_t ttbr1Mask() const { return _ttbr1Mask;}







 static Vector<AddressSpaceDescriptor> makeFullOrderedDescriptors(const Vector<AddressSpaceDescriptor> &config);

private:
 size_t _addressBits;
 size_t _ttbr1Mask;
};


extern VirtualManager virtman;
# 12 "/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/memory/VirtualMap.cpp" 2

VirtualMap::VirtualMap()
:_l0Table(nullptr),
 _l1Table(nullptr),
 _l2Table(nullptr),
 _l3Table(nullptr),
 _startAddr(),
 _phyAddr(0),
 _pageCount(0),
 _global(false)
{}

VirtualMap::VirtualMap(size_t phyPageStart,size_t pageCount,bool global,const void *vaAddr,size_t addrBits)
 :_l0Table(nullptr),
  _l1Table(nullptr),
  _l2Table(nullptr),
  _l3Table(nullptr),
  _startAddr(reinterpret_cast<uint64_t>(vaAddr),addrBits),
  _phyAddr(reinterpret_cast<const void*>(phyPageStart * _D::PAGE_SIZE)),
  _pageCount(pageCount),
  _global(global)
{
 allocateTables();
}
VirtualMap::~VirtualMap()
{
 mman.deallocate(_l0Table);
}
void VirtualMap::mapL0()
{
 uint64_t basePhyPage = reinterpret_cast<uint64_t>(virtman.translateVAToPA(_l1Table))>>_D::PAGE_BITS;
 size_t index=_startAddr.index(0);
 for(size_t i=index;i!=_sizes[0];++i)

 {

  Descriptor4KBL0::make(_l0Table+i,0);
  _l0Table[i].IsTable = 1;
  _l0Table[i].Valid = 1;
  _l0Table[i].NextLevelTableAddr = basePhyPage + i - index;
 }
}
void VirtualMap::mapL1()
{
 uint64_t basePhyPage = reinterpret_cast<uint64_t>(virtman.translateVAToPA(_l2Table))>>_D::PAGE_BITS;
 size_t index=_startAddr.index(1);
 for(size_t i=index;i!=_sizes[1];++i)
 {
  Descriptor4KBL1::make(_l1Table+i,0);
  _l1Table[i].S1.IsTable = 1;
  _l1Table[i].S1.Valid = 1;
  _l1Table[i].S1.NextLevelTableAddr = basePhyPage+i-index;
 }
}
void VirtualMap::mapL2()
{
 uint64_t basePhyPage = reinterpret_cast<uint64_t>(virtman.translateVAToPA(_l3Table))>>_D::PAGE_BITS;
 size_t index=_startAddr.index(2);
 for(size_t i=index;i!=_sizes[2];++i)
 {
  Descriptor4KBL2::make(_l2Table+i,0);
  _l2Table[i].S1.IsTable = 1;
  _l2Table[i].S1.Valid = 1;
  _l2Table[i].S1.NextLevelTableAddr = (basePhyPage+i-index);
 }
}
void VirtualMap::mapL3(const Vector<AddressSpaceDescriptor> &descr)
{
 for(size_t i=0;i!=descr.size();++i)
  ((descr[i].size() % _D::PAGE_SIZE == 0) ? (void)0 : report_assert_error("/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/memory/VirtualMap.cpp", 81, __PRETTY_FUNCTION__, "descr[i].size() % _D::PAGE_SIZE == 0"));

 size_t curGroup=0;
 while(curGroup <descr.size() && descr[curGroup].size()==0)
  ++curGroup;
 if(curGroup==descr.size())
  return;
 size_t curGroupLeftSize=descr[curGroup].size();
 size_t basePage = reinterpret_cast<size_t>(_phyAddr) >> _D::PAGE_BITS;
 size_t index=_startAddr.index(3);
 for(size_t i=index;i!=_sizes[3];++i)
 {
  Descriptor4KBL3::make(_l3Table + i, 0);

  auto type=descr[curGroup].type();

  if(type != AddressSpaceDescriptor::T_NOT_VALID && type!=AddressSpaceDescriptor::T_UNKOWN)
  {
   _l3Table[i].Valid=1;
   _l3Table[i].RES1_0=1;
   _l3Table[i].NS=1;

   _l3Table[i].OutputAddr = basePage+i-index;
   _l3Table[i].AF = 1;

   if(type==AddressSpaceDescriptor::T_NORMAL)
   {
    if(descr[curGroup].cacheable())
     _l3Table[i].AttrIndex = _D::MEMORY_ATTR_NORMAL;
    else
     _l3Table[i].AttrIndex = _D::MEMORY_ATTR_NON_CACHEABLE;
   }
   else if(type==AddressSpaceDescriptor::T_PERIPHERAL)
    _l3Table[i].AttrIndex = _D::MEMORY_ATTR_PERIPHERAL;

   _l3Table[i].PXN = 0;
   _l3Table[i].UXN = 0;
   _l3Table[i].Contiguous = 1;
   _l3Table[i].nG = (!_global);


   uint8_t ap=0;
   if(descr[curGroup].readOnly())
    ap|=(1<<1);
   if(descr[curGroup].el0Accessiable())
    ap|=1;

   _l3Table[i].AP = ap ;

   _l3Table[i].NS = 1;
   _l3Table[i].SH = 0b10;
  }
  curGroupLeftSize -= _D::PAGE_SIZE;
  if(curGroupLeftSize == 0)
  {
   while(curGroup <descr.size() && descr[curGroup].size()==0)
    ++curGroup;
   if(curGroup == descr.size())
    break;
   curGroupLeftSize = descr[curGroup].size();
  }
 }
}
void VirtualMap::allocateTables()
{
 auto size = _pageCount * _D::PAGE_SIZE;
 size_t pagesNeeded=0;
 for(size_t i=0;i!=4;++i)
 {
  size_t itPages=alignAhead(alignAhead(size,_D:: MAP_SIZE[i])/_D::MAP_SIZE[i]*_D::ENTRY_SIZE,_D::PAGE_SIZE)/_D::PAGE_SIZE;
  pagesNeeded += itPages;
  _sizes[i] = itPages*_D::PAGE_SIZE/_D::ENTRY_SIZE;
 }
 auto p = mman.allocateAs<char*>(pagesNeeded * _D::PAGE_SIZE, _D::PAGE_SIZE);
 ((p) ? (void)0 : report_assert_error("/media/sf_D_DRIVE/Pool/eclipse-workspace_aarch64/newspace/raspiOS/src/memory/VirtualMap.cpp", 155, __PRETTY_FUNCTION__, "p"));
 std::memset(p, 0, pagesNeeded * _D::PAGE_SIZE);
 _l0Table = reinterpret_cast<Descriptor4KBL0*>(p);
 _l1Table = reinterpret_cast<Descriptor4KBL1*>(_l0Table + _sizes[0]);
 _l2Table = reinterpret_cast<Descriptor4KBL2*>(_l1Table + _sizes[1]);
 _l3Table = reinterpret_cast<Descriptor4KBL3*>(_l2Table + _sizes[2]);
}
